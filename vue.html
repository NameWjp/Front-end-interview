<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Vue 的生命周期有哪些 | 前端面试题</title>
    <meta name="generator" content="VuePress 1.8.2">
    
    <meta name="description" content="">
    <meta name="referrer" content="no-referrer">
    
    <link rel="preload" href="/Front-end-interview/assets/css/0.styles.8848344e.css" as="style"><link rel="preload" href="/Front-end-interview/assets/js/app.fdae9a04.js" as="script"><link rel="preload" href="/Front-end-interview/assets/js/2.2ef4b7ab.js" as="script"><link rel="preload" href="/Front-end-interview/assets/js/7.c4e3305b.js" as="script"><link rel="prefetch" href="/Front-end-interview/assets/js/10.1936cde4.js"><link rel="prefetch" href="/Front-end-interview/assets/js/11.eb007c06.js"><link rel="prefetch" href="/Front-end-interview/assets/js/12.8bc73bd9.js"><link rel="prefetch" href="/Front-end-interview/assets/js/13.5b5be3d4.js"><link rel="prefetch" href="/Front-end-interview/assets/js/14.dd28f4e2.js"><link rel="prefetch" href="/Front-end-interview/assets/js/15.67908718.js"><link rel="prefetch" href="/Front-end-interview/assets/js/16.2b6e8ce7.js"><link rel="prefetch" href="/Front-end-interview/assets/js/17.c0560b94.js"><link rel="prefetch" href="/Front-end-interview/assets/js/18.879f6c33.js"><link rel="prefetch" href="/Front-end-interview/assets/js/19.35ca9314.js"><link rel="prefetch" href="/Front-end-interview/assets/js/20.8da81083.js"><link rel="prefetch" href="/Front-end-interview/assets/js/21.9c5e2e4f.js"><link rel="prefetch" href="/Front-end-interview/assets/js/22.79ace77f.js"><link rel="prefetch" href="/Front-end-interview/assets/js/3.895fa97e.js"><link rel="prefetch" href="/Front-end-interview/assets/js/4.99bb1ea4.js"><link rel="prefetch" href="/Front-end-interview/assets/js/5.c7ab20ec.js"><link rel="prefetch" href="/Front-end-interview/assets/js/6.b688de92.js"><link rel="prefetch" href="/Front-end-interview/assets/js/8.083d3bab.js"><link rel="prefetch" href="/Front-end-interview/assets/js/9.97deec76.js">
    <link rel="stylesheet" href="/Front-end-interview/assets/css/0.styles.8848344e.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/Front-end-interview/" class="home-link router-link-active"><!----> <span class="site-name">前端面试题</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <!----></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><!---->  <ul class="sidebar-links"><li><a href="/Front-end-interview/" aria-current="page" class="sidebar-link">简介</a></li><li><a href="/Front-end-interview/js.html" class="sidebar-link">JavaScript</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/Front-end-interview/js.html#javascript-里的最大安全数是多少-为什么" class="sidebar-link">javascript 里的最大安全数是多少，为什么</a></li><li class="sidebar-sub-header"><a href="/Front-end-interview/js.html#为什么-0-1-0-2-与-0-3-不相等-如何解决" class="sidebar-link">为什么 0.1 + 0.2 与 0.3 不相等，如何解决</a></li><li class="sidebar-sub-header"><a href="/Front-end-interview/js.html#小数四舍五入问题" class="sidebar-link">小数四舍五入问题</a></li><li class="sidebar-sub-header"><a href="/Front-end-interview/js.html#commonjs-和-es6-的区别" class="sidebar-link">commonjs 和 es6 的区别</a></li><li class="sidebar-sub-header"><a href="/Front-end-interview/js.html#什么是循环依赖" class="sidebar-link">什么是循环依赖？</a></li><li class="sidebar-sub-header"><a href="/Front-end-interview/js.html#session、cookie、token-和-jwt-的区别" class="sidebar-link">session、cookie、token 和 jwt 的区别</a></li><li class="sidebar-sub-header"><a href="/Front-end-interview/js.html#dom-事件触发流程" class="sidebar-link">DOM 事件触发流程</a></li><li class="sidebar-sub-header"><a href="/Front-end-interview/js.html#target-和-currenttarget-区别" class="sidebar-link">target 和 currentTarget 区别</a></li><li class="sidebar-sub-header"><a href="/Front-end-interview/js.html#什么是事件委托" class="sidebar-link">什么是事件委托</a></li><li class="sidebar-sub-header"><a href="/Front-end-interview/js.html#prototype-和-proto-的关系是什么" class="sidebar-link">prototype 和 __proto__ 的关系是什么</a></li><li class="sidebar-sub-header"><a href="/Front-end-interview/js.html#原型链" class="sidebar-link">原型链</a></li><li class="sidebar-sub-header"><a href="/Front-end-interview/js.html#闭包" class="sidebar-link">闭包</a></li><li class="sidebar-sub-header"><a href="/Front-end-interview/js.html#内存回收" class="sidebar-link">内存回收</a></li><li class="sidebar-sub-header"><a href="/Front-end-interview/js.html#对象浅拷贝和深拷贝有什么区别" class="sidebar-link">对象浅拷贝和深拷贝有什么区别</a></li><li class="sidebar-sub-header"><a href="/Front-end-interview/js.html#javascript-里的类型判断" class="sidebar-link">javascript 里的类型判断</a></li><li class="sidebar-sub-header"><a href="/Front-end-interview/js.html#javascript-有哪些数据类型" class="sidebar-link">javascript 有哪些数据类型</a></li><li class="sidebar-sub-header"><a href="/Front-end-interview/js.html#内置对象和函数" class="sidebar-link">内置对象和函数</a></li><li class="sidebar-sub-header"><a href="/Front-end-interview/js.html#cookie、localstorage、sessionstorage区别" class="sidebar-link">cookie、localStorage、sessionStorage区别</a></li><li class="sidebar-sub-header"><a href="/Front-end-interview/js.html#请简述-javascript-中的-this" class="sidebar-link">请简述 JavaScript 中的 this</a></li><li class="sidebar-sub-header"><a href="/Front-end-interview/js.html#window-onload-和-domcontentloaded-的区别" class="sidebar-link">window.onload 和 DOMContentLoaded 的区别</a></li><li class="sidebar-sub-header"><a href="/Front-end-interview/js.html#object-与-map-的区别" class="sidebar-link">Object 与 Map 的区别</a></li><li class="sidebar-sub-header"><a href="/Front-end-interview/js.html#为什么-weakmap-和-weakset-的键只能使用对象" class="sidebar-link">为什么 WeakMap 和 WeakSet 的键只能使用对象？</a></li><li class="sidebar-sub-header"><a href="/Front-end-interview/js.html#javascript-事件循环" class="sidebar-link">javascript 事件循环</a></li><li class="sidebar-sub-header"><a href="/Front-end-interview/js.html#图解-dom-位置关系" class="sidebar-link">图解 DOM 位置关系</a></li><li class="sidebar-sub-header"><a href="/Front-end-interview/js.html#常见的位运算符有哪些-其计算规则是什么" class="sidebar-link">常见的位运算符有哪些？其计算规则是什么？</a></li><li class="sidebar-sub-header"><a href="/Front-end-interview/js.html#escape-encodeuri-encodeuricomponent-的区别" class="sidebar-link">escape，encodeURI，encodeURIComponent 的区别</a></li><li class="sidebar-sub-header"><a href="/Front-end-interview/js.html#对象的遍历顺序" class="sidebar-link">对象的遍历顺序</a></li><li class="sidebar-sub-header"><a href="/Front-end-interview/js.html#iterator-和-for-of-循环" class="sidebar-link">Iterator 和 for...of 循环</a></li></ul></li><li><a href="/Front-end-interview/implement.html" class="sidebar-link">手写和实现</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/Front-end-interview/implement.html#async-和-generator-的关系-如何使用-generator-实现-async" class="sidebar-link">async 和 Generator 的关系，如何使用 Generator 实现 async</a></li><li class="sidebar-sub-header"><a href="/Front-end-interview/implement.html#实现-compose-函数" class="sidebar-link">实现 compose 函数</a></li><li class="sidebar-sub-header"><a href="/Front-end-interview/implement.html#实现-new-操作符" class="sidebar-link">实现 new 操作符</a></li><li class="sidebar-sub-header"><a href="/Front-end-interview/implement.html#使用-es5-和-es6-实现继承" class="sidebar-link">使用 ES5 和 ES6 实现继承</a></li><li class="sidebar-sub-header"><a href="/Front-end-interview/implement.html#实现发布-订阅模式" class="sidebar-link">实现发布/订阅模式</a></li><li class="sidebar-sub-header"><a href="/Front-end-interview/implement.html#如何实现一个可设置过期时间的-localstorage" class="sidebar-link">如何实现一个可设置过期时间的 localStorage</a></li><li class="sidebar-sub-header"><a href="/Front-end-interview/implement.html#防抖和节流函数的原理和实现" class="sidebar-link">防抖和节流函数的原理和实现</a></li><li class="sidebar-sub-header"><a href="/Front-end-interview/implement.html#函数柯里化的优点和实现" class="sidebar-link">函数柯里化的优点和实现</a></li><li class="sidebar-sub-header"><a href="/Front-end-interview/implement.html#简易-promise-的实现" class="sidebar-link">简易 Promise 的实现</a></li><li class="sidebar-sub-header"><a href="/Front-end-interview/implement.html#promise-all-和-promise-allsettled-的实现" class="sidebar-link">Promise.All 和 Promise.AllSettled 的实现</a></li></ul></li><li><a href="/Front-end-interview/typescript.html" class="sidebar-link">TypeScript</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/Front-end-interview/typescript.html#type-和-interface-的相同点和不同点" class="sidebar-link">type 和 interface 的相同点和不同点</a></li><li class="sidebar-sub-header"><a href="/Front-end-interview/typescript.html#infer-的协变和逆变" class="sidebar-link">infer 的协变和逆变</a></li><li class="sidebar-sub-header"><a href="/Front-end-interview/typescript.html#设计一个泛型-接受一个对象类型-返回一个可选的-key-的对象类型-但不能是空对象" class="sidebar-link">设计一个泛型，接受一个对象类型，返回一个可选的 key 的对象类型，但不能是空对象</a></li></ul></li><li><a href="/Front-end-interview/css.html" class="sidebar-link">CSS</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/Front-end-interview/css.html#bem-命名规范" class="sidebar-link">BEM 命名规范</a></li><li class="sidebar-sub-header"><a href="/Front-end-interview/css.html#padding-top-和-margin-top-的百分比相对于什么-为什么" class="sidebar-link">padding-top 和 margin-top 的百分比相对于什么，为什么</a></li><li class="sidebar-sub-header"><a href="/Front-end-interview/css.html#文字和图片并排居中" class="sidebar-link">文字和图片并排居中</a></li><li class="sidebar-sub-header"><a href="/Front-end-interview/css.html#文本超出部分显示省略号" class="sidebar-link">文本超出部分显示省略号</a></li><li class="sidebar-sub-header"><a href="/Front-end-interview/css.html#什么是-bfc" class="sidebar-link">什么是 BFC</a></li><li class="sidebar-sub-header"><a href="/Front-end-interview/css.html#css-作用域隔离方法" class="sidebar-link">css 作用域隔离方法</a></li><li class="sidebar-sub-header"><a href="/Front-end-interview/css.html#聊聊伪类和伪元素-伪对象" class="sidebar-link">聊聊伪类和伪元素（伪对象）</a></li><li class="sidebar-sub-header"><a href="/Front-end-interview/css.html#flex-属性的默认值" class="sidebar-link">flex 属性的默认值</a></li><li class="sidebar-sub-header"><a href="/Front-end-interview/css.html#fixed-元素相对于什么定位" class="sidebar-link">fixed 元素相对于什么定位</a></li><li class="sidebar-sub-header"><a href="/Front-end-interview/css.html#有没有遇到过-z-index-小的反而在上层的情况" class="sidebar-link">有没有遇到过 z-index 小的反而在上层的情况？</a></li><li class="sidebar-sub-header"><a href="/Front-end-interview/css.html#width-100-与-width-auto-的区别" class="sidebar-link">width:100% 与 width:auto 的区别</a></li></ul></li><li><a href="/Front-end-interview/html.html" class="sidebar-link">HTML</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/Front-end-interview/html.html#html5语义化" class="sidebar-link">HTML5语义化</a></li><li class="sidebar-sub-header"><a href="/Front-end-interview/html.html#viewport" class="sidebar-link">viewport</a></li><li class="sidebar-sub-header"><a href="/Front-end-interview/html.html#src-和-href-的区别" class="sidebar-link">src 和 href 的区别</a></li><li class="sidebar-sub-header"><a href="/Front-end-interview/html.html#defer-和-async-的区别" class="sidebar-link">defer 和 async 的区别</a></li></ul></li><li><a href="/Front-end-interview/vue.html" aria-current="page" class="active sidebar-link">Vue</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/Front-end-interview/vue.html#vue-的生命周期有哪些" class="sidebar-link">Vue 的生命周期有哪些</a></li><li class="sidebar-sub-header"><a href="/Front-end-interview/vue.html#vue-响应式原理" class="sidebar-link">Vue 响应式原理</a></li><li class="sidebar-sub-header"><a href="/Front-end-interview/vue.html#vue3-和-vue2-的区别" class="sidebar-link">Vue3 和 Vue2 的区别</a></li><li class="sidebar-sub-header"><a href="/Front-end-interview/vue.html#vue-和-react-的区别是什么" class="sidebar-link">Vue 和 React 的区别是什么</a></li><li class="sidebar-sub-header"><a href="/Front-end-interview/vue.html#vue-父子组件生命周期执行顺序" class="sidebar-link">Vue 父子组件生命周期执行顺序</a></li><li class="sidebar-sub-header"><a href="/Front-end-interview/vue.html#vue-router原理" class="sidebar-link">Vue-router原理</a></li><li class="sidebar-sub-header"><a href="/Front-end-interview/vue.html#vuex原理" class="sidebar-link">Vuex原理</a></li><li class="sidebar-sub-header"><a href="/Front-end-interview/vue.html#vue-中的-key-的作用" class="sidebar-link">Vue 中的 key 的作用</a></li><li class="sidebar-sub-header"><a href="/Front-end-interview/vue.html#virtual-dom-的优势在哪里" class="sidebar-link">Virtual Dom 的优势在哪里</a></li><li class="sidebar-sub-header"><a href="/Front-end-interview/vue.html#vue1-中的-documentfragement-有什么作用" class="sidebar-link">Vue1 中的 DocumentFragement 有什么作用</a></li><li class="sidebar-sub-header"><a href="/Front-end-interview/vue.html#vue-子组件-emit-后-props-会立刻更新吗-为什么" class="sidebar-link">Vue 子组件 $emit 后 props 会立刻更新吗？为什么</a></li><li class="sidebar-sub-header"><a href="/Front-end-interview/vue.html#vue-源码里的设计模式有哪些" class="sidebar-link">Vue 源码里的设计模式有哪些</a></li><li class="sidebar-sub-header"><a href="/Front-end-interview/vue.html#vue-虚拟-dom-diff-算法" class="sidebar-link">Vue 虚拟 DOM diff 算法</a></li><li class="sidebar-sub-header"><a href="/Front-end-interview/vue.html#vue2-和-vue3-diff-算法的区别" class="sidebar-link">Vue2 和 Vue3 diff 算法的区别</a></li><li class="sidebar-sub-header"><a href="/Front-end-interview/vue.html#vue-和-react-diff-算法的区别" class="sidebar-link">Vue 和 React diff 算法的区别</a></li></ul></li><li><a href="/Front-end-interview/react.html" class="sidebar-link">React</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/Front-end-interview/react.html#hooks-的出现解决了什么问题" class="sidebar-link">hooks 的出现解决了什么问题？</a></li><li class="sidebar-sub-header"><a href="/Front-end-interview/react.html#react-的生命周期有哪些" class="sidebar-link">React 的生命周期有哪些？</a></li><li class="sidebar-sub-header"><a href="/Front-end-interview/react.html#purecomponent-和-component-区别" class="sidebar-link">PureComponent 和 Component 区别</a></li><li class="sidebar-sub-header"><a href="/Front-end-interview/react.html#如何使用-context-上下文" class="sidebar-link">如何使用 Context 上下文</a></li><li class="sidebar-sub-header"><a href="/Front-end-interview/react.html#react-父组件调用子组件的方法" class="sidebar-link">React 父组件调用子组件的方法</a></li><li class="sidebar-sub-header"><a href="/Front-end-interview/react.html#react-组件更新流程" class="sidebar-link">React 组件更新流程</a></li><li class="sidebar-sub-header"><a href="/Front-end-interview/react.html#react-虚拟-dom-diff-算法" class="sidebar-link">React 虚拟 DOM diff 算法</a></li></ul></li><li><a href="/Front-end-interview/engineering.html" class="sidebar-link">工程化</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/Front-end-interview/engineering.html#webpack-loader-的加载顺序" class="sidebar-link">webpack Loader 的加载顺序</a></li><li class="sidebar-sub-header"><a href="/Front-end-interview/engineering.html#webpack-中-hash、chunkhash、contenthash-有什么不同" class="sidebar-link">webpack 中 hash、chunkhash、contenthash 有什么不同？</a></li><li class="sidebar-sub-header"><a href="/Front-end-interview/engineering.html#聊聊-webpack-的-tree-shaking" class="sidebar-link">聊聊 webpack 的 tree-shaking</a></li><li class="sidebar-sub-header"><a href="/Front-end-interview/engineering.html#webpack-的-sideeffects-字段应该怎么用" class="sidebar-link">webpack 的 sideEffects 字段应该怎么用</a></li><li class="sidebar-sub-header"><a href="/Front-end-interview/engineering.html#实现一个-webpack-loader-和-webpack-plugin" class="sidebar-link">实现一个 webpack loader 和 webpack plugin</a></li><li class="sidebar-sub-header"><a href="/Front-end-interview/engineering.html#webpack-打包后代码里的-esmodule-和-pure-是用来干嘛的" class="sidebar-link">webpack 打包后代码里的 __esModule 和 __PURE__ 是用来干嘛的</a></li><li class="sidebar-sub-header"><a href="/Front-end-interview/engineering.html#webpack-splitchunks-如何使用" class="sidebar-link">webpack splitChunks 如何使用</a></li><li class="sidebar-sub-header"><a href="/Front-end-interview/engineering.html#es6-的-async-await-编译为-es5-是什么样子" class="sidebar-link">ES6 的 async await 编译为 ES5 是什么样子</a></li></ul></li><li><a href="/Front-end-interview/browser.html" class="sidebar-link">浏览器</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/Front-end-interview/browser.html#什么是同源政策有哪些限制" class="sidebar-link">什么是同源政策有哪些限制</a></li><li class="sidebar-sub-header"><a href="/Front-end-interview/browser.html#为什么浏览器的-js-线程和-ui-线程是互斥的" class="sidebar-link">为什么浏览器的 JS 线程和 UI 线程是互斥的？</a></li><li class="sidebar-sub-header"><a href="/Front-end-interview/browser.html#跨域资源共享-cors" class="sidebar-link">跨域资源共享（CORS）</a></li><li class="sidebar-sub-header"><a href="/Front-end-interview/browser.html#在浏览器输入-url-回车之后发生了什么" class="sidebar-link">在浏览器输入 URL 回车之后发生了什么</a></li></ul></li><li><a href="/Front-end-interview/http.html" class="sidebar-link">HTTP</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/Front-end-interview/http.html#get-post-请求有什么区别" class="sidebar-link">GET/POST 请求有什么区别</a></li><li class="sidebar-sub-header"><a href="/Front-end-interview/http.html#一个-tcp-连接能发几个-http-请求" class="sidebar-link">一个 TCP 连接能发几个 HTTP 请求?</a></li><li class="sidebar-sub-header"><a href="/Front-end-interview/http.html#http-缓存" class="sidebar-link">HTTP 缓存</a></li><li class="sidebar-sub-header"><a href="/Front-end-interview/http.html#keep-alive-和多路复用的区别" class="sidebar-link">keep-alive 和多路复用的区别</a></li><li class="sidebar-sub-header"><a href="/Front-end-interview/http.html#http-状态码" class="sidebar-link">HTTP 状态码</a></li><li class="sidebar-sub-header"><a href="/Front-end-interview/http.html#https加密过程详解" class="sidebar-link">HTTPS加密过程详解</a></li><li class="sidebar-sub-header"><a href="/Front-end-interview/http.html#域名解析流程" class="sidebar-link">域名解析流程</a></li></ul></li><li><a href="/Front-end-interview/node.html" class="sidebar-link">Node</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/Front-end-interview/node.html#package-json-依赖项版本号前面的-有什么用" class="sidebar-link">package.json 依赖项版本号前面的 ~ ^ 有什么用？</a></li><li class="sidebar-sub-header"><a href="/Front-end-interview/node.html#项目中使用-package-lock-json-锁版本问题" class="sidebar-link">项目中使用 package-lock.json 锁版本问题</a></li><li class="sidebar-sub-header"><a href="/Front-end-interview/node.html#peerdependencies-有什么用" class="sidebar-link">peerDependencies 有什么用</a></li><li class="sidebar-sub-header"><a href="/Front-end-interview/node.html#require-原理" class="sidebar-link">require 原理</a></li></ul></li><li><a href="/Front-end-interview/arithmetic.html" class="sidebar-link">算法</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/Front-end-interview/arithmetic.html#手写冒泡算法" class="sidebar-link">手写冒泡算法</a></li><li class="sidebar-sub-header"><a href="/Front-end-interview/arithmetic.html#根据-value-获取叶子节点" class="sidebar-link">根据 value 获取叶子节点</a></li><li class="sidebar-sub-header"><a href="/Front-end-interview/arithmetic.html#根据-value-获取叶子节点的路径" class="sidebar-link">根据 value 获取叶子节点的路径</a></li><li class="sidebar-sub-header"><a href="/Front-end-interview/arithmetic.html#列表结构转树结构" class="sidebar-link">列表结构转树结构</a></li><li class="sidebar-sub-header"><a href="/Front-end-interview/arithmetic.html#实现洗牌算法" class="sidebar-link">实现洗牌算法</a></li><li class="sidebar-sub-header"><a href="/Front-end-interview/arithmetic.html#二叉树遍历-前序、中序、后序、广度优先" class="sidebar-link">二叉树遍历(前序、中序、后序、广度优先)</a></li></ul></li><li><a href="/Front-end-interview/safe.html" class="sidebar-link">前端安全</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/Front-end-interview/safe.html#什么是-xss" class="sidebar-link">什么是 XSS</a></li><li class="sidebar-sub-header"><a href="/Front-end-interview/safe.html#什么是-csrf" class="sidebar-link">什么是 CSRF</a></li><li class="sidebar-sub-header"><a href="/Front-end-interview/safe.html#什么是-csp" class="sidebar-link">什么是 CSP</a></li><li class="sidebar-sub-header"><a href="/Front-end-interview/safe.html#cookie-的保护方式" class="sidebar-link">Cookie 的保护方式</a></li><li class="sidebar-sub-header"><a href="/Front-end-interview/safe.html#常见的编码和加密算法" class="sidebar-link">常见的编码和加密算法</a></li></ul></li><li><a href="/Front-end-interview/optimize.html" class="sidebar-link">前端优化</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/Front-end-interview/optimize.html#图片优化" class="sidebar-link">图片优化</a></li><li class="sidebar-sub-header"><a href="/Front-end-interview/optimize.html#http请求" class="sidebar-link">HTTP请求</a></li><li class="sidebar-sub-header"><a href="/Front-end-interview/optimize.html#webpack-的优化" class="sidebar-link">webpack 的优化</a></li><li class="sidebar-sub-header"><a href="/Front-end-interview/optimize.html#使用-cdn-加载静态资源" class="sidebar-link">使用 CDN 加载静态资源</a></li><li class="sidebar-sub-header"><a href="/Front-end-interview/optimize.html#合理放置-css-和-js-的位置" class="sidebar-link">合理放置 CSS 和 JS 的位置</a></li><li class="sidebar-sub-header"><a href="/Front-end-interview/optimize.html#使用缓存" class="sidebar-link">使用缓存</a></li><li class="sidebar-sub-header"><a href="/Front-end-interview/optimize.html#减少重绘和重排" class="sidebar-link">减少重绘和重排</a></li><li class="sidebar-sub-header"><a href="/Front-end-interview/optimize.html#使用事件委托" class="sidebar-link">使用事件委托</a></li><li class="sidebar-sub-header"><a href="/Front-end-interview/optimize.html#大量计算使用-web-workers" class="sidebar-link">大量计算使用 Web Workers</a></li><li class="sidebar-sub-header"><a href="/Front-end-interview/optimize.html#dns-prefetch-和-preconnect" class="sidebar-link">DNS-prefetch 和 Preconnect</a></li><li class="sidebar-sub-header"><a href="/Front-end-interview/optimize.html#preload-和-prefetch" class="sidebar-link">preload 和 prefetch</a></li><li class="sidebar-sub-header"><a href="/Front-end-interview/optimize.html#开启-gzip-压缩" class="sidebar-link">开启 gzip 压缩</a></li><li class="sidebar-sub-header"><a href="/Front-end-interview/optimize.html#vue-优化" class="sidebar-link">Vue 优化</a></li><li class="sidebar-sub-header"><a href="/Front-end-interview/optimize.html#react-优化" class="sidebar-link">React 优化</a></li><li class="sidebar-sub-header"><a href="/Front-end-interview/optimize.html#hybrid-app-下的性能优化" class="sidebar-link">Hybrid App 下的性能优化</a></li><li class="sidebar-sub-header"><a href="/Front-end-interview/optimize.html#首屏渲染白屏时间如何优化" class="sidebar-link">首屏渲染白屏时间如何优化</a></li></ul></li><li><a href="/Front-end-interview/other.html" class="sidebar-link">其他</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/Front-end-interview/other.html#单点登录" class="sidebar-link">单点登录</a></li><li class="sidebar-sub-header"><a href="/Front-end-interview/other.html#正则表达式" class="sidebar-link">正则表达式</a></li><li class="sidebar-sub-header"><a href="/Front-end-interview/other.html#ascii、gbk、utf、unicode" class="sidebar-link">Ascii、GBK、UTF、Unicode</a></li><li class="sidebar-sub-header"><a href="/Front-end-interview/other.html#git-merge-和-git-rebase区别" class="sidebar-link">git merge 和 git rebase区别</a></li><li class="sidebar-sub-header"><a href="/Front-end-interview/other.html#为什么引用值要放在堆中-而原始值要放在栈中" class="sidebar-link">为什么引用值要放在堆中，而原始值要放在栈中</a></li><li class="sidebar-sub-header"><a href="/Front-end-interview/other.html#nginx-常见配置" class="sidebar-link">Nginx 常见配置</a></li><li class="sidebar-sub-header"><a href="/Front-end-interview/other.html#mvc、mcp、mvvm-的区别" class="sidebar-link">MVC、MCP、MVVM 的区别</a></li><li class="sidebar-sub-header"><a href="/Front-end-interview/other.html#观察者模式和发布订阅模式的区别" class="sidebar-link">观察者模式和发布订阅模式的区别</a></li><li class="sidebar-sub-header"><a href="/Front-end-interview/other.html#常见的缓存淘汰算法有哪些" class="sidebar-link">常见的缓存淘汰算法有哪些</a></li><li class="sidebar-sub-header"><a href="/Front-end-interview/other.html#依赖注入中如何解决循环依赖" class="sidebar-link">依赖注入中如何解决循环依赖</a></li></ul></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h2 id="vue-的生命周期有哪些"><a href="#vue-的生命周期有哪些" class="header-anchor">#</a> Vue 的生命周期有哪些</h2> <p><img src="/Front-end-interview/assets/img/vue_lifecycle.f64aebb5.png" alt=""><br>
Vue 的生命周期如图，总结如下：</p> <ol><li>beforeCreate<br>
只初始化一些事件，data 数据没有初始化，无法访问。</li> <li>created<br>
data 数据已经初始化，可以访问，但此时的 dom 没有挂载，可以在这里进行请求服务器数据等操作。</li> <li>beforeMount<br>
dom 挂载，但是 dom 中存在类似  的占位符，并没有替换。</li> <li>mounted<br>
此时组件渲染完毕，占位符也都被替换。</li> <li>beforeUpdate 和 updated<br>
组件触发更新时，会立刻先调用 beforeUpdate，等到重新渲染完之后调用 updated 钩子</li> <li>beforeDestroy 和 destroyed<br>
组件在销毁前会调用 beforeDestroy 钩子，可以在这里进行一些定时器或者销毁操作。destroyed 钩子函数会在 Vue 实例销毁后调用。</li> <li>activated 和 deactivated<br>
如果组件被 keep-alive 包裹，第一次渲染会在 mounted 钩子后面调用 activated 钩子，离开的时候不会调用 beforeDestroy 和 destroyed 钩子，而是调用 deactivated 钩子，等到再切换回来的时候，activated 钩子会调用（不会再走 mounted 钩子）。</li> <li>errorCaptured<br>
用于捕获子组件中抛出的错误，注意只有 errorCaptured 返回 false 则可以阻止错误继续向上传播（本质上是说“这个错误已经被搞定了且应该被忽略”）。</li></ol> <h2 id="vue-响应式原理"><a href="#vue-响应式原理" class="header-anchor">#</a> Vue 响应式原理</h2> <p><img src="/Front-end-interview/assets/img/vue_init_process.82f6441a.png" alt=""><br>
Vue 的初始化如图所示，在执行 Observer 的时候会递归遍历 data 中的对象和数组，将对象的 key 全部通过 Object.defineProperty 定义，重新拦截对象的 get 和 set，内部会通过闭包引用一个 dep，在 get 中通过 depend 将当前的渲染 watcher push 到 dep 中的数组中，完成订阅。在 set 中通过遍历之前的数组，触发每个渲染 watcher 的 update，从而派发更新。对于数组，采用的是代理模式，拦截数组的原型，在 push 等改变数组方法调用时，手动派发更新。<br>
另外在 data 中每个对象和数组都会有一个  <code>__ob__</code> 属性，里面保存的是一个 dep 实例。为什么需要这个属性呢？因为在 es5 中有些情况我们没法检测到变化，例如对象属性的增减，所以这里我们需要提前收集与这个对象有关的 watcher 信息，在用户手动调用 <code>$set</code> 方法时去派发更新，相关代码如下：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> childOb <span class="token operator">=</span> <span class="token operator">!</span>shallow <span class="token operator">&amp;&amp;</span> <span class="token function">observe</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span>
Object<span class="token punctuation">.</span><span class="token function">defineProperty</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> key<span class="token punctuation">,</span> <span class="token punctuation">{</span>
  enumerable<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
  configurable<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
  <span class="token function-variable function">get</span><span class="token operator">:</span> <span class="token keyword">function</span> <span class="token function">reactiveGetter</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> value <span class="token operator">=</span> getter <span class="token operator">?</span> <span class="token function">getter</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span> <span class="token operator">:</span> val
    <span class="token keyword">if</span> <span class="token punctuation">(</span>Dep<span class="token punctuation">.</span>target<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      dep<span class="token punctuation">.</span><span class="token function">depend</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
      <span class="token comment">// 这里就是提前收集相关 watcher 的地方</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>childOb<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        childOb<span class="token punctuation">.</span>dep<span class="token punctuation">.</span><span class="token function">depend</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>Array<span class="token punctuation">.</span><span class="token function">isArray</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
          <span class="token function">dependArray</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> value
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p><code>__ob__</code>属性如下：<br> <img src="/Front-end-interview/assets/img/vue_ob_data.3ee2a8a0.png" alt=""><br>
最后说下 Watcher，在 Vue 中 watcher 有三种：render watcher/ computed watcher/ user watcher(就是Vue方法中的那个watch)，Watcher 类的作用是 vm 实例和 Observer 的桥梁，负责管理 dep，vm 等。比如 Observer 的 set 方法触发了 watcher 的 update 去更新， watcher 的 update 会调用 vm 的 _update 从而更新视图。</p> <h2 id="vue3-和-vue2-的区别"><a href="#vue3-和-vue2-的区别" class="header-anchor">#</a> Vue3 和 Vue2 的区别</h2> <p>Vue3 除了性能提升外，相比 Vue2 有以下特点：</p> <ol><li>使用 Proxy 替代 Object.defineProperty<br>
替换之后对象或数组可以在没有提前定义 key 的情况下直接赋值。（Object.defineProperty 需要提前知道 key 才能拦截这个 key 的访问，而 Proxy 是直接拦截整个对象的访问）</li> <li>增加 Composition API<br>
在 Vue2 中我们会在一个 Vue 文件中 data，methods，computed，watch 中定义属性和方法，共同处理页面逻辑。一个功能往往需要在不同的 Vue 配置项中定义属性和方法，比较分散。即使通过 Mixins 重用逻辑代码，也容易发生命名冲突且关系不清。<br>
在 Vue3 Composition API 中，代码是根据逻辑功能来组织的，一个功能的所有 api 会放在一起（高内聚，低耦合），这样做，即时项目很大，功能很多，都能快速的定位到这个功能所用到的所有 API。提高可读性和可维护性，而且基于函数组合的 API 更好的重用逻辑代码（和 React 的 Hooks 类似）。</li> <li>全面支持 TypeScript<br>
内部采用 TypeScript 重写，并在工具链上提供对 TypeScript 的支持。</li></ol> <h2 id="vue-和-react-的区别是什么"><a href="#vue-和-react-的区别是什么" class="header-anchor">#</a> Vue 和 React 的区别是什么</h2> <p>设计理念不同，React 强调数据的不可变（immutable），而 Vue 的数据是可变的，通过 getter/setter 以及一些函数的劫持，能精确知道数据变化。比如改变一个对象属性的值，在 Vue 可以直接修改，而在 React 需要拿一个新对象替换旧对象。使用不可变有以下好处：</p> <ol><li>在使用不可变的数据后，React 不需要深层次的比较对象是否被改变，只需要判断当前对象和之前的对象引用是否相同。</li> <li>由于使用的不可变数据，在每次改变数据的时候可以得到之前的快照，可以很方便的追踪数据的变化。</li> <li>降低了可变对象的复杂度，比如下面的一段代码：</li></ol> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">touchAndLog</span><span class="token punctuation">(</span><span class="token parameter">touchFn</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> data <span class="token operator">=</span> <span class="token punctuation">{</span> key<span class="token operator">:</span> <span class="token string">'value'</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token function">touchFn</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>data<span class="token punctuation">.</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 猜猜会打印什么？</span>
<span class="token punctuation">}</span>
</code></pre></div><p>如果使用 immutable 则我们可以确定打印的是 { key: 'value' }。</p> <p>使用不可变的数据在维护上更加方便，但也有它的缺点:</p> <ol><li>由于只知道对象改变了，不知道哪个地方改变了，所以 React 会对新旧对象生成的 VNode diff，在对象数据很庞大的时候会相当耗时，从而阻塞 ui 线程，界面就会给人卡住的感觉，这也是 Fiber 架构出现的原因。而 Vue 得益于它的依赖收集，改变一个对象的属性后能够精准的知道哪些 watcher 需要重新渲染，然后在这个基础上再进行 VNode diff 渲染等工作（相比 React 省去了一部分的 diff）。所以 Vue 从理论上性能是好于 React 的。</li> <li>由于 React 强调每次数据都是一个新值，当要修改一个对象的值的时候就必须先克隆一个副本，然后在副本的基础上去修改值。而对象的属性值有可能有嵌套对象，如果采用浅拷贝那么仍然会有公共的部分（事实上我自己开发就是采用的这种方法），如果采用深拷贝又会带来性能的昂贵开销。折中的解决办法是 Facebook 开源的 immutable.js 库，Immutable实现的原理是 Persistent Data Structur（持久化数据结构），对 Immutable 对象的任何修改或添加删除操作都会返回一个新的 Immutable 对象, 同时使用旧数据创建新数据时，要保证旧数据同时可用且不变。流程如下：<br> <img src="/Front-end-interview/assets/img/immutable_create.2b4c801a.gif" alt=""><br>
由于我自身没有用过 immutable.js，所以不做太多评价，但从使用过的人的评价来看，还是有不少问题的，推荐链接：<a href="https://juejin.cn/post/6844903859618332680" target="_blank" rel="noopener noreferrer">https://juejin.cn/post/6844903859618332680<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ol> <p>当然两种框架由于设计理念的不同，走上了不同的道路，没有高低优劣之分。个人感觉 Vue 在官方支持上面比 React 更好，包括路由，状态管理等，都是由官方维护，且都有详细的文档。但 React 更加灵活，且比较纯粹，但是有许多问题都是由社区来解决，所以会有五花八门的库，选择和学习上会有一定困难。其实 Vue3 出来后，和 React 在灵活性上已经差不多了，Composition API 和 Hooks 思路是一样的，大家根据自己的爱好合理选择即可。<br>
另外推荐一篇文章：<a href="http://hcysun.me/2018/01/05/%E6%8E%A2%E7%B4%A2Vue%E9%AB%98%E9%98%B6%E7%BB%84%E4%BB%B6/" target="_blank" rel="noopener noreferrer">http://hcysun.me/2018/01/05/%E6%8E%A2%E7%B4%A2Vue%E9%AB%98%E9%98%B6%E7%BB%84%E4%BB%B6/<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 关于 Vue2 中高阶组件的实现。</p> <h2 id="vue-父子组件生命周期执行顺序"><a href="#vue-父子组件生命周期执行顺序" class="header-anchor">#</a> Vue 父子组件生命周期执行顺序</h2> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 渲染</span>
parent beforeCreate
parent created
parent beforeMount
sub beforeCreate
sub created
sub beforeMount
sub mounted
parent mounted

<span class="token comment">// 数据更新</span>
parent beforeUpdate
sub beforeUpdate
sub updated
parent updated

<span class="token comment">// 销毁组件</span>
parent beforeDestroy
sub beforeDestroy
sub destroyed
parent destroyed

</code></pre></div><p>注意 <code>mounted</code> 不会保证所有的子组件也都一起被挂载，因为可能有异步组件的存在。</p> <h2 id="vue-router原理"><a href="#vue-router原理" class="header-anchor">#</a> Vue-router原理</h2> <p>简单的说，Vue-router 的原理就是通过监听 URL 地址的变化，从注册的路由中渲染相应的组件。根据类型分为 hash 模式和 history 模式。hash 模式实现原理是基于 <code>window.location.hash</code> 来获取对应的 hash 值，改变 hash 值并不会刷新页面，通过监听 <code>onhashchange</code> 事件来获取用户改变 hash 的行为。history 模式依赖于 <code>history</code> 提供的接口，例如 <code>history.pushState</code> 可以修改 url 但并不会刷新页面，每次触发 history.back() 或者浏览器的后退按钮等，会触发一个 <code>popstate</code> 事件（history.pushState 和 history.replaceState 方法并不会触发 popstate 事件，解决办法是创建自定义事件，详见参考链接），通过监听该事件可以获取用户改变 url 的行为。但 history 模式有一个缺点，如果用户手动刷新页面，如果服务器没有配置 url 对应的资源，则会返回 404，常见的写法如下（nginx 配置）：</p> <div class="language- extra-class"><pre class="language-text"><code>location /es6/ {
  try_files $uri $uri/ /es6/index.html;
  index index.html;
}
</code></pre></div><p>参考链接：<a href="https://segmentfault.com/a/1190000017560688" target="_blank" rel="noopener noreferrer">https://segmentfault.com/a/1190000017560688<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <h2 id="vuex原理"><a href="#vuex原理" class="header-anchor">#</a> Vuex原理</h2> <p>Vuex 的内部会初始化一个 store 实例（store 内部会实例化一个 Vue 实例 vm 用于响应式处理，Vuex 和 Vue 强关联），之后会将 store 实例挂载到所有组件中，这样所有组件引用的都是同一个 store 实例。访问 store 实例里的数据会被代理到内部的 vm 实例上，这样一旦修改了 store 实例的数据，vm 便会通知所有视图更新数据。</p> <h2 id="vue-中的-key-的作用"><a href="#vue-中的-key-的作用" class="header-anchor">#</a> Vue 中的 key 的作用</h2> <p>组件中 key 是用来标识组件（React 同理）。在 Vue 进行更新的时候会进行新旧 VNode 节点的对比，如果 key 不相同，会直接销毁旧的 vnode，渲染新的 vnode。如果 key 相同则会更新复用 vnode。<br>
一个比较常见的错误：在会出现增删的列表循环中使用 index 作为 key。比如渲染一个长度为 3 的列表，列表的每一个元素的 key 分别为 <code>1 2 3</code>，此时删除了第一个元素。</p> <ul><li>理想状态：删除第一个元素的 dom 即可。</li> <li>实际情况：Vue 在渲染的时候发现列表的 key 由 <code>1 2 3</code> 变成了 <code>1 2</code>，则会删除最后一个元素的 dom，然后更新第一和第二个元素的数据，从而错误的更新。如果第一个元素和第二个元素有非受控的状态，页面会直接显示错误。</li></ul> <p>比较好的做法是使用 id 作为 key，如果没有 id，则在获取到列表的时候通过某种规则为它们创建一个 key，并保证这个 key 在组件整个生命周期中都保持稳定。<br>
推荐链接：<a href="https://juejin.cn/post/6844904113587634184" target="_blank" rel="noopener noreferrer">https://juejin.cn/post/6844904113587634184<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <h2 id="virtual-dom-的优势在哪里"><a href="#virtual-dom-的优势在哪里" class="header-anchor">#</a> Virtual Dom 的优势在哪里</h2> <p>JS 线程和 UI 线程是互斥的，JS 代码调用 DOM API 必须挂起 JS 线程、转换传入参数数据、激活 UI 线程，DOM 重绘后再转换可能有的返回值，最后激活 JS 线程并继续执行。若有频繁的 DOM API 调用，引擎间切换的代价将迅速积累。若其中有强制重绘的 DOM API 调用，重新计算布局、重新绘制图像会引起更大的性能消耗。</p> <p>VDOM 的本质是一种描述真实 DOM 的数据结构，相比直接修改 DOM 有以下优点：</p> <ol><li>虚拟 DOM 进行频繁修改，然后一次性比较并修改真实 DOM 中需要改的部分，最后在真实 DOM 中进行排版与重绘，减少过多 DOM 节点排版与重绘损耗，减少频繁的引擎切换的开销。</li> <li>虚拟 DOM 有效降低大面积真实 DOM 的重绘与排版，因为最终与真实 DOM 比较差异，可以只渲染局部</li> <li>由于虚拟 DOM 会帮助我们更新 DOM，所以我们只需要关注数据的变化，极大的减少了心智负担，提高了开发效率。</li></ol> <p>虚拟 dom 好处这么多，渲染速度上是不是比直接操作真实 dom 快呢？并不是。虚拟 dom 增加了一层内存运算，然后才操作真实 dom，将数据渲染到页面上。渲染上肯定会慢上一些。虽然虚拟 dom 的缺点在初始化时增加了内存运算，增加了首页的渲染时间，但是运算时间是以毫秒级别或微秒级别算出的，对用户体验影响并不是很大。</p> <p>参考：<a href="https://mp.weixin.qq.com/s?__biz=MzA5ODM5NTYyMA==&amp;mid=2653284927&amp;idx=1&amp;sn=afb56f99533b7404b4fe52aea2eec154&amp;chksm=8b437eb4bc34f7a27acf4694c6219ae4ec172b78b651e8ca4577115ac000052f7348266b28b7&amp;scene=126&amp;sessionid=1677719179#rd" target="_blank" rel="noopener noreferrer">2023 年最新最全的 React 面试题<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <h2 id="vue1-中的-documentfragement-有什么作用"><a href="#vue1-中的-documentfragement-有什么作用" class="header-anchor">#</a> Vue1 中的 DocumentFragement 有什么作用</h2> <p>文档碎片主要的作用是用来提高页面性能，考虑如下问题：在 document.body 中添加 100 个 span</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">100</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> 
  <span class="token keyword">var</span> op <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">&quot;span&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
  <span class="token keyword">var</span> oText <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createTextNode</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span> 
  op<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>oText<span class="token punctuation">)</span><span class="token punctuation">;</span> 
  document<span class="token punctuation">.</span>body<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>op<span class="token punctuation">)</span><span class="token punctuation">;</span> 
<span class="token punctuation">}</span> 
</code></pre></div><p>这样写性能就会很差，不断的向 body 中插入元素会导致页面不断的触发重排，发生页面卡顿的现象。当然你也可以新建一个 div 将 span 都放到 div 中，最后再将 div 插入到 body 中，但这样 dom 中会多出一个 div 节点。更好的做法是使用 createDocumentFragment 创建一个文档碎片节点，将 span 临时放入碎片节点中，最后一次性插入到 body:</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">//先创建文档碎片</span>
<span class="token keyword">var</span> oFragmeng <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createDocumentFragment</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 

<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">100</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> 
  <span class="token keyword">var</span> op <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">&quot;span&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
  <span class="token keyword">var</span> oText <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createTextNode</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span> 
  op<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>oText<span class="token punctuation">)</span><span class="token punctuation">;</span> 
  <span class="token comment">//先附加在文档碎片中</span>
  oFragmeng<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>op<span class="token punctuation">)</span><span class="token punctuation">;</span>  
<span class="token punctuation">}</span> 

<span class="token comment">//最后一次性添加到document中</span>
document<span class="token punctuation">.</span>body<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>oFragmeng<span class="token punctuation">)</span><span class="token punctuation">;</span> 
</code></pre></div><h2 id="vue-子组件-emit-后-props-会立刻更新吗-为什么"><a href="#vue-子组件-emit-后-props-会立刻更新吗-为什么" class="header-anchor">#</a> Vue 子组件 $emit 后 props 会立刻更新吗？为什么</h2> <p>不会，我们知道 Vue 的更新是异步的，同一时间修改多次 <strong>data</strong> 实际只会更新一次视图，这样做可以大大减少 dom 更新的次数，提高性能。所以当子组件 <strong>$emit</strong> 后实际是修改父组件的 <strong>data</strong>，之后会异步的执行父组件的 <strong>render</strong> 方法更新，在 <strong>render</strong> 方法中会传入新的 <strong>data</strong> 用来更新子组件。所以子组件 <strong>$emit</strong> 后，<strong>props</strong> 只有等到页面重新渲染后才会更新。</p> <h2 id="vue-源码里的设计模式有哪些"><a href="#vue-源码里的设计模式有哪些" class="header-anchor">#</a> Vue 源码里的设计模式有哪些</h2> <h3 id="发布订阅模式"><a href="#发布订阅模式" class="header-anchor">#</a> 发布订阅模式</h3> <p>Vue 的响应式用到了发布订阅模式，初始化的时候会对组件的 data 数据拦截，组件访问 data 的属性后会订阅该属性的变化，等到该属性修改后通知之前订阅的组件。</p> <h3 id="工厂模式"><a href="#工厂模式" class="header-anchor">#</a> 工厂模式</h3> <p>Vue3 的 createApp 函数可以创建多个 Vue 实例，工厂函数代替直接 new 对象，降低了模块间的耦合性。</p> <h3 id="策略模式"><a href="#策略模式" class="header-anchor">#</a> 策略模式</h3> <p>Vue 抽象出一份响应式代码，不同平台实现相应的接口即可实现多平台的渲染，例如 weex 和 web 两个平台。</p> <h3 id="代理模式"><a href="#代理模式" class="header-anchor">#</a> 代理模式</h3> <p>Vue 通过代理数组的原型方法，来实现数组的响应式（例：通过 push 方法插入元素会导致视图更新）。</p> <h2 id="vue-虚拟-dom-diff-算法"><a href="#vue-虚拟-dom-diff-算法" class="header-anchor">#</a> Vue 虚拟 DOM diff 算法</h2> <p>传统的 diff 算法从一颗树转换到另一颗树，时间复杂度为 O(n^3)，Vue 借鉴了 React 的 diff 思想，也实现了复杂度为 O(n) 的算法，主要遵循以下基本原则：</p> <ol><li><p><strong>同级比较</strong>：<br>
Vue 的 diff 算法只比较同级别的节点，而不是跨层级比较。如果一个节点在旧树中存在但在新树中不存在，那么这个节点将被移除；如果新树中有一个节点在旧树中不存在，那么这个节点将被创建。</p></li> <li><p><strong>可重用节点的检测</strong>：<br>
Vue 通过相同的 <code>key</code> 属性检测哪些子节点是可重用的。<code>key</code> 是一个特殊的属性，当子节点拥有唯一的 <code>key</code> 值时，Vue 会用这个 <code>key</code> 来匹配新旧虚拟 DOM 之间的子节点。如果没有 <code>key</code>，Vue 将默认使用节点的类型和顺序作为重用的依据。</p></li> <li><p><strong>更新子节点</strong>：<br>
当比较两个相同类型的节点时，Vue 会执行更新操作，这包括确保节点的类型相同，并更新具有相同 <code>key</code> 的节点的属性、事件监听器等。对于子节点，Vue 会递归地进行 diff 操作。</p></li> <li><p><strong>列表对比优化</strong>：<br>
在处理列表时，Vue 会尝试最大限度地重用现有的子节点，减少不必要的 DOM 操作。Vue 实现了一个高效的算法来处理列表项的插入、移动和删除操作。这个算法基于两个简单的假设：</p> <ul><li>列表的头部或尾部是变化最频繁的区域。</li> <li>创建新的节点通常比移动现有节点更昂贵。</li></ul> <p>因此，Vue 在更新列表时，会尝试从头部或尾部开始比较，并且在必要时移动节点，而不是替换它们。</p></li></ol> <p>Vue 的 diff 算法的核心是一个递归的过程，它尝试尽可能地减少对真实 DOM 的操作，因为这些操作通常是性能瓶颈。通过仅更新实际更改的部分，Vue 可以实现快速的响应式 UI 更新。</p> <h2 id="vue2-和-vue3-diff-算法的区别"><a href="#vue2-和-vue3-diff-算法的区别" class="header-anchor">#</a> Vue2 和 Vue3 diff 算法的区别</h2> <p>Vue 2 和 Vue 3 都使用虚拟 DOM 和 diff 算法来更新 DOM，但是在 Vue 3 中，diff 算法经过了优化，以提供更好的性能和更小的内存占用。下面是 Vue 2 和 Vue 3 在 diff 算法方面的一些主要区别：</p> <ol><li><p><strong>静态树提升</strong>：<br>
Vue 3 会自动检测模板中的静态根节点，并在编译时将它们提升，这意味着在 diff 过程中，这些节点及其子节点不需要被比较，因为它们不会改变。这减少了 diff 过程中需要比较的节点数量。Vue 2 中没有这种优化。</p></li> <li><p><strong>静态属性提升</strong>：<br>
类似地，Vue 3 在编译时会提升那些不会改变的静态属性，这样在重新渲染时就不需要再次对这些属性进行处理。Vue 2 则会在每次渲染时检查所有属性。</p></li> <li><p><strong>片段（Fragments）</strong>：<br>
Vue 3 支持 Fragments，这意味着组件可以有多个根节点。在 Vue 2 中，每个组件必须有一个单独的根节点。这在 Vue 3 中改变了 diff 算法，因为它需要能够处理多个根节点的情况。</p></li> <li><p><strong>编译时优化</strong>：<br>
Vue 3 的编译器可以更智能地生成代码，以减少运行时的工作量。例如，它可以确定哪些子树是动态的，哪些是静态的，从而避免在动态子树中进行不必要的检查。Vue 2 的编译器做了一些类似的优化，但没有 Vue 3 那么高级。</p></li> <li><p><strong>更好的块跟踪</strong>：<br>
Vue 3 引入了块（blocks）的概念，这是一种新的内部数据结构，用于跟踪静态节点和动态节点的边界，这样在更新时可以更快地找到需要 diff 的节点。</p></li> <li><p><strong>优化的事件处理器</strong>：<br>
Vue 3 在处理事件监听器时也进行了优化，通过使用缓存的事件处理器来减少不必要的重新渲染。</p></li></ol> <p>总结来说，Vue 3 的 diff 算法和 Vue 2 相比，进行了许多优化，这些优化旨在减少需要比较和渲染的节点数量，以及减少内存占用和提高性能。这些改进使得 Vue 3 在处理大型和复杂应用时更加高效。</p> <h2 id="vue-和-react-diff-算法的区别"><a href="#vue-和-react-diff-算法的区别" class="header-anchor">#</a> Vue 和 React diff 算法的区别</h2> <ol><li><p><strong>组件更新的优化</strong>
Vue 的组件有一个静态树优化。在编译模板时，它能够检测出静态的根节点，并在 diff 过程中直接跳过它们。这意味着如果组件的某些部分在任何时候都不会改变，Vue 在编译时就会知道，并在后续的更新中省去比对这些静态节点。React 不会在编译时对组件进行静态分析，所有的组件都会在更新时进行 diff。</p></li> <li><p><strong>列表比对处理不同</strong><br>
Vue 的列表比对，采用从两端到中间的比对方式。而 React 则采用从左到右依次比对的方式，在某些场景 Vue 的对比方式更高效。</p></li></ol></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/Front-end-interview/html.html" class="prev">
        HTML
      </a></span> <span class="next"><a href="/Front-end-interview/react.html">
        React
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/Front-end-interview/assets/js/app.fdae9a04.js" defer></script><script src="/Front-end-interview/assets/js/2.2ef4b7ab.js" defer></script><script src="/Front-end-interview/assets/js/7.c4e3305b.js" defer></script>
  </body>
</html>
