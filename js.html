<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>javascript 里的最大安全数是多少，为什么 | 前端面试题</title>
    <meta name="generator" content="VuePress 1.8.2">
    
    <meta name="description" content="">
    <meta name="referrer" content="no-referrer">
    
    <link rel="preload" href="/Front-end-interview/assets/css/0.styles.8848344e.css" as="style"><link rel="preload" href="/Front-end-interview/assets/js/app.fdae9a04.js" as="script"><link rel="preload" href="/Front-end-interview/assets/js/2.2ef4b7ab.js" as="script"><link rel="preload" href="/Front-end-interview/assets/js/4.99bb1ea4.js" as="script"><link rel="prefetch" href="/Front-end-interview/assets/js/10.1936cde4.js"><link rel="prefetch" href="/Front-end-interview/assets/js/11.eb007c06.js"><link rel="prefetch" href="/Front-end-interview/assets/js/12.8bc73bd9.js"><link rel="prefetch" href="/Front-end-interview/assets/js/13.5b5be3d4.js"><link rel="prefetch" href="/Front-end-interview/assets/js/14.dd28f4e2.js"><link rel="prefetch" href="/Front-end-interview/assets/js/15.67908718.js"><link rel="prefetch" href="/Front-end-interview/assets/js/16.2b6e8ce7.js"><link rel="prefetch" href="/Front-end-interview/assets/js/17.c0560b94.js"><link rel="prefetch" href="/Front-end-interview/assets/js/18.879f6c33.js"><link rel="prefetch" href="/Front-end-interview/assets/js/19.35ca9314.js"><link rel="prefetch" href="/Front-end-interview/assets/js/20.8da81083.js"><link rel="prefetch" href="/Front-end-interview/assets/js/21.9c5e2e4f.js"><link rel="prefetch" href="/Front-end-interview/assets/js/22.79ace77f.js"><link rel="prefetch" href="/Front-end-interview/assets/js/3.895fa97e.js"><link rel="prefetch" href="/Front-end-interview/assets/js/5.c7ab20ec.js"><link rel="prefetch" href="/Front-end-interview/assets/js/6.b688de92.js"><link rel="prefetch" href="/Front-end-interview/assets/js/7.c4e3305b.js"><link rel="prefetch" href="/Front-end-interview/assets/js/8.083d3bab.js"><link rel="prefetch" href="/Front-end-interview/assets/js/9.97deec76.js">
    <link rel="stylesheet" href="/Front-end-interview/assets/css/0.styles.8848344e.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/Front-end-interview/" class="home-link router-link-active"><!----> <span class="site-name">前端面试题</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <!----></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><!---->  <ul class="sidebar-links"><li><a href="/Front-end-interview/" aria-current="page" class="sidebar-link">简介</a></li><li><a href="/Front-end-interview/js.html" aria-current="page" class="active sidebar-link">JavaScript</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/Front-end-interview/js.html#javascript-里的最大安全数是多少-为什么" class="sidebar-link">javascript 里的最大安全数是多少，为什么</a></li><li class="sidebar-sub-header"><a href="/Front-end-interview/js.html#为什么-0-1-0-2-与-0-3-不相等-如何解决" class="sidebar-link">为什么 0.1 + 0.2 与 0.3 不相等，如何解决</a></li><li class="sidebar-sub-header"><a href="/Front-end-interview/js.html#小数四舍五入问题" class="sidebar-link">小数四舍五入问题</a></li><li class="sidebar-sub-header"><a href="/Front-end-interview/js.html#commonjs-和-es6-的区别" class="sidebar-link">commonjs 和 es6 的区别</a></li><li class="sidebar-sub-header"><a href="/Front-end-interview/js.html#什么是循环依赖" class="sidebar-link">什么是循环依赖？</a></li><li class="sidebar-sub-header"><a href="/Front-end-interview/js.html#session、cookie、token-和-jwt-的区别" class="sidebar-link">session、cookie、token 和 jwt 的区别</a></li><li class="sidebar-sub-header"><a href="/Front-end-interview/js.html#dom-事件触发流程" class="sidebar-link">DOM 事件触发流程</a></li><li class="sidebar-sub-header"><a href="/Front-end-interview/js.html#target-和-currenttarget-区别" class="sidebar-link">target 和 currentTarget 区别</a></li><li class="sidebar-sub-header"><a href="/Front-end-interview/js.html#什么是事件委托" class="sidebar-link">什么是事件委托</a></li><li class="sidebar-sub-header"><a href="/Front-end-interview/js.html#prototype-和-proto-的关系是什么" class="sidebar-link">prototype 和 __proto__ 的关系是什么</a></li><li class="sidebar-sub-header"><a href="/Front-end-interview/js.html#原型链" class="sidebar-link">原型链</a></li><li class="sidebar-sub-header"><a href="/Front-end-interview/js.html#闭包" class="sidebar-link">闭包</a></li><li class="sidebar-sub-header"><a href="/Front-end-interview/js.html#内存回收" class="sidebar-link">内存回收</a></li><li class="sidebar-sub-header"><a href="/Front-end-interview/js.html#对象浅拷贝和深拷贝有什么区别" class="sidebar-link">对象浅拷贝和深拷贝有什么区别</a></li><li class="sidebar-sub-header"><a href="/Front-end-interview/js.html#javascript-里的类型判断" class="sidebar-link">javascript 里的类型判断</a></li><li class="sidebar-sub-header"><a href="/Front-end-interview/js.html#javascript-有哪些数据类型" class="sidebar-link">javascript 有哪些数据类型</a></li><li class="sidebar-sub-header"><a href="/Front-end-interview/js.html#内置对象和函数" class="sidebar-link">内置对象和函数</a></li><li class="sidebar-sub-header"><a href="/Front-end-interview/js.html#cookie、localstorage、sessionstorage区别" class="sidebar-link">cookie、localStorage、sessionStorage区别</a></li><li class="sidebar-sub-header"><a href="/Front-end-interview/js.html#请简述-javascript-中的-this" class="sidebar-link">请简述 JavaScript 中的 this</a></li><li class="sidebar-sub-header"><a href="/Front-end-interview/js.html#window-onload-和-domcontentloaded-的区别" class="sidebar-link">window.onload 和 DOMContentLoaded 的区别</a></li><li class="sidebar-sub-header"><a href="/Front-end-interview/js.html#object-与-map-的区别" class="sidebar-link">Object 与 Map 的区别</a></li><li class="sidebar-sub-header"><a href="/Front-end-interview/js.html#为什么-weakmap-和-weakset-的键只能使用对象" class="sidebar-link">为什么 WeakMap 和 WeakSet 的键只能使用对象？</a></li><li class="sidebar-sub-header"><a href="/Front-end-interview/js.html#javascript-事件循环" class="sidebar-link">javascript 事件循环</a></li><li class="sidebar-sub-header"><a href="/Front-end-interview/js.html#图解-dom-位置关系" class="sidebar-link">图解 DOM 位置关系</a></li><li class="sidebar-sub-header"><a href="/Front-end-interview/js.html#常见的位运算符有哪些-其计算规则是什么" class="sidebar-link">常见的位运算符有哪些？其计算规则是什么？</a></li><li class="sidebar-sub-header"><a href="/Front-end-interview/js.html#escape-encodeuri-encodeuricomponent-的区别" class="sidebar-link">escape，encodeURI，encodeURIComponent 的区别</a></li><li class="sidebar-sub-header"><a href="/Front-end-interview/js.html#对象的遍历顺序" class="sidebar-link">对象的遍历顺序</a></li><li class="sidebar-sub-header"><a href="/Front-end-interview/js.html#iterator-和-for-of-循环" class="sidebar-link">Iterator 和 for...of 循环</a></li></ul></li><li><a href="/Front-end-interview/implement.html" class="sidebar-link">手写和实现</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/Front-end-interview/implement.html#async-和-generator-的关系-如何使用-generator-实现-async" class="sidebar-link">async 和 Generator 的关系，如何使用 Generator 实现 async</a></li><li class="sidebar-sub-header"><a href="/Front-end-interview/implement.html#实现-compose-函数" class="sidebar-link">实现 compose 函数</a></li><li class="sidebar-sub-header"><a href="/Front-end-interview/implement.html#实现-new-操作符" class="sidebar-link">实现 new 操作符</a></li><li class="sidebar-sub-header"><a href="/Front-end-interview/implement.html#使用-es5-和-es6-实现继承" class="sidebar-link">使用 ES5 和 ES6 实现继承</a></li><li class="sidebar-sub-header"><a href="/Front-end-interview/implement.html#实现发布-订阅模式" class="sidebar-link">实现发布/订阅模式</a></li><li class="sidebar-sub-header"><a href="/Front-end-interview/implement.html#如何实现一个可设置过期时间的-localstorage" class="sidebar-link">如何实现一个可设置过期时间的 localStorage</a></li><li class="sidebar-sub-header"><a href="/Front-end-interview/implement.html#防抖和节流函数的原理和实现" class="sidebar-link">防抖和节流函数的原理和实现</a></li><li class="sidebar-sub-header"><a href="/Front-end-interview/implement.html#函数柯里化的优点和实现" class="sidebar-link">函数柯里化的优点和实现</a></li><li class="sidebar-sub-header"><a href="/Front-end-interview/implement.html#简易-promise-的实现" class="sidebar-link">简易 Promise 的实现</a></li><li class="sidebar-sub-header"><a href="/Front-end-interview/implement.html#promise-all-和-promise-allsettled-的实现" class="sidebar-link">Promise.All 和 Promise.AllSettled 的实现</a></li></ul></li><li><a href="/Front-end-interview/typescript.html" class="sidebar-link">TypeScript</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/Front-end-interview/typescript.html#type-和-interface-的相同点和不同点" class="sidebar-link">type 和 interface 的相同点和不同点</a></li><li class="sidebar-sub-header"><a href="/Front-end-interview/typescript.html#infer-的协变和逆变" class="sidebar-link">infer 的协变和逆变</a></li><li class="sidebar-sub-header"><a href="/Front-end-interview/typescript.html#设计一个泛型-接受一个对象类型-返回一个可选的-key-的对象类型-但不能是空对象" class="sidebar-link">设计一个泛型，接受一个对象类型，返回一个可选的 key 的对象类型，但不能是空对象</a></li></ul></li><li><a href="/Front-end-interview/css.html" class="sidebar-link">CSS</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/Front-end-interview/css.html#bem-命名规范" class="sidebar-link">BEM 命名规范</a></li><li class="sidebar-sub-header"><a href="/Front-end-interview/css.html#padding-top-和-margin-top-的百分比相对于什么-为什么" class="sidebar-link">padding-top 和 margin-top 的百分比相对于什么，为什么</a></li><li class="sidebar-sub-header"><a href="/Front-end-interview/css.html#文字和图片并排居中" class="sidebar-link">文字和图片并排居中</a></li><li class="sidebar-sub-header"><a href="/Front-end-interview/css.html#文本超出部分显示省略号" class="sidebar-link">文本超出部分显示省略号</a></li><li class="sidebar-sub-header"><a href="/Front-end-interview/css.html#什么是-bfc" class="sidebar-link">什么是 BFC</a></li><li class="sidebar-sub-header"><a href="/Front-end-interview/css.html#css-作用域隔离方法" class="sidebar-link">css 作用域隔离方法</a></li><li class="sidebar-sub-header"><a href="/Front-end-interview/css.html#聊聊伪类和伪元素-伪对象" class="sidebar-link">聊聊伪类和伪元素（伪对象）</a></li><li class="sidebar-sub-header"><a href="/Front-end-interview/css.html#flex-属性的默认值" class="sidebar-link">flex 属性的默认值</a></li><li class="sidebar-sub-header"><a href="/Front-end-interview/css.html#fixed-元素相对于什么定位" class="sidebar-link">fixed 元素相对于什么定位</a></li><li class="sidebar-sub-header"><a href="/Front-end-interview/css.html#有没有遇到过-z-index-小的反而在上层的情况" class="sidebar-link">有没有遇到过 z-index 小的反而在上层的情况？</a></li><li class="sidebar-sub-header"><a href="/Front-end-interview/css.html#width-100-与-width-auto-的区别" class="sidebar-link">width:100% 与 width:auto 的区别</a></li></ul></li><li><a href="/Front-end-interview/html.html" class="sidebar-link">HTML</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/Front-end-interview/html.html#html5语义化" class="sidebar-link">HTML5语义化</a></li><li class="sidebar-sub-header"><a href="/Front-end-interview/html.html#viewport" class="sidebar-link">viewport</a></li><li class="sidebar-sub-header"><a href="/Front-end-interview/html.html#src-和-href-的区别" class="sidebar-link">src 和 href 的区别</a></li><li class="sidebar-sub-header"><a href="/Front-end-interview/html.html#defer-和-async-的区别" class="sidebar-link">defer 和 async 的区别</a></li></ul></li><li><a href="/Front-end-interview/vue.html" class="sidebar-link">Vue</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/Front-end-interview/vue.html#vue-的生命周期有哪些" class="sidebar-link">Vue 的生命周期有哪些</a></li><li class="sidebar-sub-header"><a href="/Front-end-interview/vue.html#vue-响应式原理" class="sidebar-link">Vue 响应式原理</a></li><li class="sidebar-sub-header"><a href="/Front-end-interview/vue.html#vue3-和-vue2-的区别" class="sidebar-link">Vue3 和 Vue2 的区别</a></li><li class="sidebar-sub-header"><a href="/Front-end-interview/vue.html#vue-和-react-的区别是什么" class="sidebar-link">Vue 和 React 的区别是什么</a></li><li class="sidebar-sub-header"><a href="/Front-end-interview/vue.html#vue-父子组件生命周期执行顺序" class="sidebar-link">Vue 父子组件生命周期执行顺序</a></li><li class="sidebar-sub-header"><a href="/Front-end-interview/vue.html#vue-router原理" class="sidebar-link">Vue-router原理</a></li><li class="sidebar-sub-header"><a href="/Front-end-interview/vue.html#vuex原理" class="sidebar-link">Vuex原理</a></li><li class="sidebar-sub-header"><a href="/Front-end-interview/vue.html#vue-中的-key-的作用" class="sidebar-link">Vue 中的 key 的作用</a></li><li class="sidebar-sub-header"><a href="/Front-end-interview/vue.html#virtual-dom-的优势在哪里" class="sidebar-link">Virtual Dom 的优势在哪里</a></li><li class="sidebar-sub-header"><a href="/Front-end-interview/vue.html#vue1-中的-documentfragement-有什么作用" class="sidebar-link">Vue1 中的 DocumentFragement 有什么作用</a></li><li class="sidebar-sub-header"><a href="/Front-end-interview/vue.html#vue-子组件-emit-后-props-会立刻更新吗-为什么" class="sidebar-link">Vue 子组件 $emit 后 props 会立刻更新吗？为什么</a></li><li class="sidebar-sub-header"><a href="/Front-end-interview/vue.html#vue-源码里的设计模式有哪些" class="sidebar-link">Vue 源码里的设计模式有哪些</a></li><li class="sidebar-sub-header"><a href="/Front-end-interview/vue.html#vue-虚拟-dom-diff-算法" class="sidebar-link">Vue 虚拟 DOM diff 算法</a></li><li class="sidebar-sub-header"><a href="/Front-end-interview/vue.html#vue2-和-vue3-diff-算法的区别" class="sidebar-link">Vue2 和 Vue3 diff 算法的区别</a></li><li class="sidebar-sub-header"><a href="/Front-end-interview/vue.html#vue-和-react-diff-算法的区别" class="sidebar-link">Vue 和 React diff 算法的区别</a></li></ul></li><li><a href="/Front-end-interview/react.html" class="sidebar-link">React</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/Front-end-interview/react.html#hooks-的出现解决了什么问题" class="sidebar-link">hooks 的出现解决了什么问题？</a></li><li class="sidebar-sub-header"><a href="/Front-end-interview/react.html#react-的生命周期有哪些" class="sidebar-link">React 的生命周期有哪些？</a></li><li class="sidebar-sub-header"><a href="/Front-end-interview/react.html#purecomponent-和-component-区别" class="sidebar-link">PureComponent 和 Component 区别</a></li><li class="sidebar-sub-header"><a href="/Front-end-interview/react.html#如何使用-context-上下文" class="sidebar-link">如何使用 Context 上下文</a></li><li class="sidebar-sub-header"><a href="/Front-end-interview/react.html#react-父组件调用子组件的方法" class="sidebar-link">React 父组件调用子组件的方法</a></li><li class="sidebar-sub-header"><a href="/Front-end-interview/react.html#react-组件更新流程" class="sidebar-link">React 组件更新流程</a></li><li class="sidebar-sub-header"><a href="/Front-end-interview/react.html#react-虚拟-dom-diff-算法" class="sidebar-link">React 虚拟 DOM diff 算法</a></li></ul></li><li><a href="/Front-end-interview/engineering.html" class="sidebar-link">工程化</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/Front-end-interview/engineering.html#webpack-loader-的加载顺序" class="sidebar-link">webpack Loader 的加载顺序</a></li><li class="sidebar-sub-header"><a href="/Front-end-interview/engineering.html#webpack-中-hash、chunkhash、contenthash-有什么不同" class="sidebar-link">webpack 中 hash、chunkhash、contenthash 有什么不同？</a></li><li class="sidebar-sub-header"><a href="/Front-end-interview/engineering.html#聊聊-webpack-的-tree-shaking" class="sidebar-link">聊聊 webpack 的 tree-shaking</a></li><li class="sidebar-sub-header"><a href="/Front-end-interview/engineering.html#webpack-的-sideeffects-字段应该怎么用" class="sidebar-link">webpack 的 sideEffects 字段应该怎么用</a></li><li class="sidebar-sub-header"><a href="/Front-end-interview/engineering.html#实现一个-webpack-loader-和-webpack-plugin" class="sidebar-link">实现一个 webpack loader 和 webpack plugin</a></li><li class="sidebar-sub-header"><a href="/Front-end-interview/engineering.html#webpack-打包后代码里的-esmodule-和-pure-是用来干嘛的" class="sidebar-link">webpack 打包后代码里的 __esModule 和 __PURE__ 是用来干嘛的</a></li><li class="sidebar-sub-header"><a href="/Front-end-interview/engineering.html#webpack-splitchunks-如何使用" class="sidebar-link">webpack splitChunks 如何使用</a></li><li class="sidebar-sub-header"><a href="/Front-end-interview/engineering.html#es6-的-async-await-编译为-es5-是什么样子" class="sidebar-link">ES6 的 async await 编译为 ES5 是什么样子</a></li></ul></li><li><a href="/Front-end-interview/browser.html" class="sidebar-link">浏览器</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/Front-end-interview/browser.html#什么是同源政策有哪些限制" class="sidebar-link">什么是同源政策有哪些限制</a></li><li class="sidebar-sub-header"><a href="/Front-end-interview/browser.html#为什么浏览器的-js-线程和-ui-线程是互斥的" class="sidebar-link">为什么浏览器的 JS 线程和 UI 线程是互斥的？</a></li><li class="sidebar-sub-header"><a href="/Front-end-interview/browser.html#跨域资源共享-cors" class="sidebar-link">跨域资源共享（CORS）</a></li><li class="sidebar-sub-header"><a href="/Front-end-interview/browser.html#在浏览器输入-url-回车之后发生了什么" class="sidebar-link">在浏览器输入 URL 回车之后发生了什么</a></li></ul></li><li><a href="/Front-end-interview/http.html" class="sidebar-link">HTTP</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/Front-end-interview/http.html#get-post-请求有什么区别" class="sidebar-link">GET/POST 请求有什么区别</a></li><li class="sidebar-sub-header"><a href="/Front-end-interview/http.html#一个-tcp-连接能发几个-http-请求" class="sidebar-link">一个 TCP 连接能发几个 HTTP 请求?</a></li><li class="sidebar-sub-header"><a href="/Front-end-interview/http.html#http-缓存" class="sidebar-link">HTTP 缓存</a></li><li class="sidebar-sub-header"><a href="/Front-end-interview/http.html#keep-alive-和多路复用的区别" class="sidebar-link">keep-alive 和多路复用的区别</a></li><li class="sidebar-sub-header"><a href="/Front-end-interview/http.html#http-状态码" class="sidebar-link">HTTP 状态码</a></li><li class="sidebar-sub-header"><a href="/Front-end-interview/http.html#https加密过程详解" class="sidebar-link">HTTPS加密过程详解</a></li><li class="sidebar-sub-header"><a href="/Front-end-interview/http.html#域名解析流程" class="sidebar-link">域名解析流程</a></li></ul></li><li><a href="/Front-end-interview/node.html" class="sidebar-link">Node</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/Front-end-interview/node.html#package-json-依赖项版本号前面的-有什么用" class="sidebar-link">package.json 依赖项版本号前面的 ~ ^ 有什么用？</a></li><li class="sidebar-sub-header"><a href="/Front-end-interview/node.html#项目中使用-package-lock-json-锁版本问题" class="sidebar-link">项目中使用 package-lock.json 锁版本问题</a></li><li class="sidebar-sub-header"><a href="/Front-end-interview/node.html#peerdependencies-有什么用" class="sidebar-link">peerDependencies 有什么用</a></li><li class="sidebar-sub-header"><a href="/Front-end-interview/node.html#require-原理" class="sidebar-link">require 原理</a></li></ul></li><li><a href="/Front-end-interview/arithmetic.html" class="sidebar-link">算法</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/Front-end-interview/arithmetic.html#手写冒泡算法" class="sidebar-link">手写冒泡算法</a></li><li class="sidebar-sub-header"><a href="/Front-end-interview/arithmetic.html#根据-value-获取叶子节点" class="sidebar-link">根据 value 获取叶子节点</a></li><li class="sidebar-sub-header"><a href="/Front-end-interview/arithmetic.html#根据-value-获取叶子节点的路径" class="sidebar-link">根据 value 获取叶子节点的路径</a></li><li class="sidebar-sub-header"><a href="/Front-end-interview/arithmetic.html#列表结构转树结构" class="sidebar-link">列表结构转树结构</a></li><li class="sidebar-sub-header"><a href="/Front-end-interview/arithmetic.html#实现洗牌算法" class="sidebar-link">实现洗牌算法</a></li><li class="sidebar-sub-header"><a href="/Front-end-interview/arithmetic.html#二叉树遍历-前序、中序、后序、广度优先" class="sidebar-link">二叉树遍历(前序、中序、后序、广度优先)</a></li></ul></li><li><a href="/Front-end-interview/safe.html" class="sidebar-link">前端安全</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/Front-end-interview/safe.html#什么是-xss" class="sidebar-link">什么是 XSS</a></li><li class="sidebar-sub-header"><a href="/Front-end-interview/safe.html#什么是-csrf" class="sidebar-link">什么是 CSRF</a></li><li class="sidebar-sub-header"><a href="/Front-end-interview/safe.html#什么是-csp" class="sidebar-link">什么是 CSP</a></li><li class="sidebar-sub-header"><a href="/Front-end-interview/safe.html#cookie-的保护方式" class="sidebar-link">Cookie 的保护方式</a></li><li class="sidebar-sub-header"><a href="/Front-end-interview/safe.html#常见的编码和加密算法" class="sidebar-link">常见的编码和加密算法</a></li></ul></li><li><a href="/Front-end-interview/optimize.html" class="sidebar-link">前端优化</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/Front-end-interview/optimize.html#图片优化" class="sidebar-link">图片优化</a></li><li class="sidebar-sub-header"><a href="/Front-end-interview/optimize.html#http请求" class="sidebar-link">HTTP请求</a></li><li class="sidebar-sub-header"><a href="/Front-end-interview/optimize.html#webpack-的优化" class="sidebar-link">webpack 的优化</a></li><li class="sidebar-sub-header"><a href="/Front-end-interview/optimize.html#使用-cdn-加载静态资源" class="sidebar-link">使用 CDN 加载静态资源</a></li><li class="sidebar-sub-header"><a href="/Front-end-interview/optimize.html#合理放置-css-和-js-的位置" class="sidebar-link">合理放置 CSS 和 JS 的位置</a></li><li class="sidebar-sub-header"><a href="/Front-end-interview/optimize.html#使用缓存" class="sidebar-link">使用缓存</a></li><li class="sidebar-sub-header"><a href="/Front-end-interview/optimize.html#减少重绘和重排" class="sidebar-link">减少重绘和重排</a></li><li class="sidebar-sub-header"><a href="/Front-end-interview/optimize.html#使用事件委托" class="sidebar-link">使用事件委托</a></li><li class="sidebar-sub-header"><a href="/Front-end-interview/optimize.html#大量计算使用-web-workers" class="sidebar-link">大量计算使用 Web Workers</a></li><li class="sidebar-sub-header"><a href="/Front-end-interview/optimize.html#dns-prefetch-和-preconnect" class="sidebar-link">DNS-prefetch 和 Preconnect</a></li><li class="sidebar-sub-header"><a href="/Front-end-interview/optimize.html#preload-和-prefetch" class="sidebar-link">preload 和 prefetch</a></li><li class="sidebar-sub-header"><a href="/Front-end-interview/optimize.html#开启-gzip-压缩" class="sidebar-link">开启 gzip 压缩</a></li><li class="sidebar-sub-header"><a href="/Front-end-interview/optimize.html#vue-优化" class="sidebar-link">Vue 优化</a></li><li class="sidebar-sub-header"><a href="/Front-end-interview/optimize.html#react-优化" class="sidebar-link">React 优化</a></li><li class="sidebar-sub-header"><a href="/Front-end-interview/optimize.html#hybrid-app-下的性能优化" class="sidebar-link">Hybrid App 下的性能优化</a></li><li class="sidebar-sub-header"><a href="/Front-end-interview/optimize.html#首屏渲染白屏时间如何优化" class="sidebar-link">首屏渲染白屏时间如何优化</a></li></ul></li><li><a href="/Front-end-interview/other.html" class="sidebar-link">其他</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/Front-end-interview/other.html#单点登录" class="sidebar-link">单点登录</a></li><li class="sidebar-sub-header"><a href="/Front-end-interview/other.html#正则表达式" class="sidebar-link">正则表达式</a></li><li class="sidebar-sub-header"><a href="/Front-end-interview/other.html#ascii、gbk、utf、unicode" class="sidebar-link">Ascii、GBK、UTF、Unicode</a></li><li class="sidebar-sub-header"><a href="/Front-end-interview/other.html#git-merge-和-git-rebase区别" class="sidebar-link">git merge 和 git rebase区别</a></li><li class="sidebar-sub-header"><a href="/Front-end-interview/other.html#为什么引用值要放在堆中-而原始值要放在栈中" class="sidebar-link">为什么引用值要放在堆中，而原始值要放在栈中</a></li><li class="sidebar-sub-header"><a href="/Front-end-interview/other.html#nginx-常见配置" class="sidebar-link">Nginx 常见配置</a></li><li class="sidebar-sub-header"><a href="/Front-end-interview/other.html#mvc、mcp、mvvm-的区别" class="sidebar-link">MVC、MCP、MVVM 的区别</a></li><li class="sidebar-sub-header"><a href="/Front-end-interview/other.html#观察者模式和发布订阅模式的区别" class="sidebar-link">观察者模式和发布订阅模式的区别</a></li><li class="sidebar-sub-header"><a href="/Front-end-interview/other.html#常见的缓存淘汰算法有哪些" class="sidebar-link">常见的缓存淘汰算法有哪些</a></li><li class="sidebar-sub-header"><a href="/Front-end-interview/other.html#依赖注入中如何解决循环依赖" class="sidebar-link">依赖注入中如何解决循环依赖</a></li></ul></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h2 id="javascript-里的最大安全数是多少-为什么"><a href="#javascript-里的最大安全数是多少-为什么" class="header-anchor">#</a> javascript 里的最大安全数是多少，为什么</h2> <p>js里采用 IEEE754 标准，采用双精度存储数值，存储结构如下。<br> <img src="/Front-end-interview/assets/img/js_number_save.934a9258.png" alt=""></p> <p>所谓 “安全整数”，就是说该整数与其双精度浮点数表示是一一对应的，即该整数有且仅有一个双精度浮点数表示，其该双精度浮点数表示有且仅有一个对应的整数。例如在控制台打印如下内容：</p> <div class="language- extra-class"><pre class="language-text"><code>&gt; Math.pow(2, 53)
9007199254740992
&gt; Math.pow(2, 53) + 1
9007199254740992
</code></pre></div><p>说明 2^53 并不是最大安全数，它和 2^53 + 1 对应一个整数</p> <div class="language- extra-class"><pre class="language-text"><code>2^53 是这样存的：
符号位：0 指数：53 尾数：1.000000...000 （小数点后一共52个0）

2^53 + 1：
符号位：0 指数：53 尾数：1.000000...000 （小数点后一共52个0）
</code></pre></div><p>为什么 +1 没有被存进去？因为尾数部分最多只能存 52 位，超出这个位数的数字尾部会被忽略，再考虑到默认第一位总是 1 不计入 52 位中，所以最大安全数是：2^53 - 1</p> <p>不过由于 ES6 的普及，出现了新的数据类型 BigInt，它可以表示任意大的整数，在一定程度上 js 也就没有最大安全数这个概念了。</p> <p>参考：</p> <ul><li><a href="https://blog.windstone.cc/js/data-types/number/floating.html#%E8%AE%A1%E7%AE%97%E8%AF%AF%E5%B7%AE" target="_blank" rel="noopener noreferrer">https://blog.windstone.cc/js/data-types/number/floating.html#%E8%AE%A1%E7%AE%97%E8%AF%AF%E5%B7%AE<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><a href="https://www.zhihu.com/question/29010688" target="_blank" rel="noopener noreferrer">https://www.zhihu.com/question/29010688<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><a href="https://github.com/camsong/blog/issues/9" target="_blank" rel="noopener noreferrer">https://github.com/camsong/blog/issues/9<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul> <h2 id="为什么-0-1-0-2-与-0-3-不相等-如何解决"><a href="#为什么-0-1-0-2-与-0-3-不相等-如何解决" class="header-anchor">#</a> 为什么 0.1 + 0.2 与 0.3 不相等，如何解决</h2> <p>js里采用 IEEE754 标准，采用双精度存储数值，将 0.1 和 0.2 转化成二进制的时候会无限循环。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token number">0.1</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token number">0.0001100110011001</span><span class="token operator">...</span><span class="token punctuation">(</span>无限循环<span class="token punctuation">)</span>
<span class="token number">0.2</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token number">0.0011001100110011</span><span class="token operator">...</span><span class="token punctuation">(</span>无限循环<span class="token punctuation">)</span>
</code></pre></div><p>所以必然会存在精度丢失的问题。<br>
解决方法：写一个公共方法，在计算的时候将 0.1 等小数转化整数，运算完成后再将其转化成小数。或者使用一些计算库，例如：<a href="https://github.com/nefe/number-precision" target="_blank" rel="noopener noreferrer">number-precision<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <h2 id="小数四舍五入问题"><a href="#小数四舍五入问题" class="header-anchor">#</a> 小数四舍五入问题</h2> <p>在使用 toFixed 去四舍五入的时候会出现一些奇怪的问题如下：<br> <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAWgAAAESCAMAAADngr9AAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyRpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMy1jMDExIDY2LjE0NTY2MSwgMjAxMi8wMi8wNi0xNDo1NjoyNyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNiAoTWFjaW50b3NoKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDpENUVENDcyRUM1NjkxMUU3OUVFQzlBRjdFNTI0Q0VDNCIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDpENUVENDcyRkM1NjkxMUU3OUVFQzlBRjdFNTI0Q0VDNCI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOkQ1RUQ0NzJDQzU2OTExRTc5RUVDOUFGN0U1MjRDRUM0IiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOkQ1RUQ0NzJEQzU2OTExRTc5RUVDOUFGN0U1MjRDRUM0Ii8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+UMIsfwAAAYBQTFRFuru7ycj1+Ofn8PDw+fr6ysvN/Pz87e387u7u9fX12m5usbO1p6TuUlVY7ry7aGPh9dnZ5JSU5uX7xiIglJSUJBLU09L2qqqqMSfX6OnqIyMjREtU+/Ly2dnZ3N3doaSpdnyBl5TrSUHc6KmpZWty01VUzkNBwcHBe3flVlDd0dHR4OHiyzY1pKSkS1Jam5+j1tbW9vb9gIWL34KCztDS78PC+vn+WF5lNj5H8vL88crJmZmZvbzzxBsX/Pz+vb7AhoLoXGJp5ebmjZKWxMTE0tTVPERM8vLybW1tpqmt/fn5rbCzbXJ5s7W4tbPxvsHElZmezM7P2dj4foOInaGlqq2wx8jK3t352drc4+Xmj5SZ/vz81tfYtri7wMLFh4uR3d7fcnd919nb3Nzd1l9g88/Q0U1NGwHS9/f48fLy4uPj8/PzQ0NDwsTHsK7wPzbZ7Ozt3+Hi6urrIArT7u/v6OjpyC0rxcbH8fHxkI3q0dPVzTw8TEbbMTlC/v7+////fWD6qQAAHbtJREFUeNrsnftfElv3xzFxlNC8lGRHkUxSgVQ0L6gIZWBfE000UBN9KC058i15PFL2nGbmX//utee25z6Ap1ffh71+UAaGYfOetddlD/Bx8dR+ibkoAgqagqZGQVPQFDQ1CpqCpkZBU9AUdCNWznzI3eJoNjMfPL8lpoNgMN3YqBsE/Ypl527x/WRZ9tXtU6pms+Wan1RJJg/lDaaLjVUaG3VjoCMsm2GI7f3Ozs52s53jI5J1JmB7Sd7+sS/uwmXY2GED42E2AoqVpHtzLNtW86HQk3YUSiy7QTzGtaD3mVA2nYy6IdDcv1QO7QudI2sx2TnRfS7ZJR6kT95WnjPHsv+yfMWdxfVh84c966xssWvpXm890w49aVq67e4ijsZz8Us05H7CoexGbQqaYRxOrxjbJe/aEtJA0zLSgt41AO2espqj6CCPLaGVBo1A5xoF3UaATGz34yGToO1GbQq6WuGcTq+AdHup/9wedGd7H5gwRgR6oE+wBXmvAMtuNgQ6dnAlmvweyhcXTCOg4UXlVCjNQxK03ahNQDOn3q2ok5FBivi3DHrg/HxkZsIatOoxBDqUMIj6XVavjd5zwRp0mb8VI0BXWXbQTYy6fxu9WRVou1EbgnY/8q6sbEbd9k59SB5+4UnnjB6mDeifCaOTZ5ZYvgQCGygmZCDjHYvDK86yi7HBjZICulV94ja3kG2KE/s/04Fj0cvfBaZvhHElX6KDBuV06ZmOsbHHBy4FdJKsKvr64wl+RgPaatTmoNdyKw9WHvo9tqSTurLGDrRP69G61+BmWfbE5ABBJQCzXfgUcRtSQD4wAZ0THhcxHqCbeSkadGEvrU6Jh9gTfKaqhPlpJeVrhqQFbTFqi9DhDj9cefBgsmBL+r0uMtmB7p8IhV74FNDnE92h7q8zZklIc4DpxZfgfLFgMLg4y0gYY7N78PdQAq3OSiexKSApxfVjVtgBvUrsEeYagzmyA8fdg/frAc57O7FBBTRyV/bUGrTFqC1Ac4w/9wCRDpdsijsyRzgDLVj3Eq+qOv6Kkz0YmsaMw2T4J6rmMsgvizGxLCCrjjRvUN5xe/jwRdmzMyy7DrPhC7rno3gG0M7lrkEZHWK/XrYBbT1q06rD4/c+QNGjzdqnDSoAZ6DPB2Y05V2nshti8NIp6BNEqSQWsuvXGtBzRqCxxwaYKakbQYDEfI58/THDM8i1vWIClEDDNLm2AW09avOGxXO6BXG67Ya5RY9+MeFb4hZaoNr/IaSVr6iuax9R10o1gIbIOC0VsvhuAD24iG39oyFo7Mys/BpeiBgMWBXfh+aIEHvghRTQth5dL2i+FPGiOP2urcLcmkeTHWL/EnFHCyI9UhdoeUO6ZVzeqTtDL06ej+RTpRjCeUCegmmzUuYWQfPMxUMUp1fC5VsHzfedq8sPDhXf3YmGQPM7LJs0nuU60PAsqUTAt8lesvi7gs7XAXrhUrPTNllQv0V5jasZ9KbQoxow0YF2oyJCamjhCDvZvGhtOEsOGoGu2IC2HrVV6ChuQugIXzPWHfh0HaB1O/nIFvGdeqHMDnRadcsBaKiKkWWldTd1o6lUD8dKHZ3RzVwdaOtRWyRDvxeSYfa15XQo6GoaNUM0HM2agHy3CnQn4dHwrtKqRkA371Wgj1UsHIBGHV/sAyv5aEADCJXVgyWpSZC8aENHUdewZHR1gbPyLorLu6xNy4JStCYdq0EvGYOOozv7yOz45Pz8hbRxrTqmEENJd9ohN3PSmYZibNgR6AgEaOAiPNElhwp5HU4g5lbqaAOH0q51XOtIOALtjkJ8fhh228UA5G/fHXt0S6fQAfr6z8+fIAdeEFvEBZQLz+NEaTzLWYD2ksEQqCXF3XAuMgZ9rLhbaQo/v3VdxAj14CsB4p/TEcGRX7oFV5dBwypoVZ1mBtSFk3rUjlfv5oDzpL9ku9hRwEW+9OIhZEA2FLr0GYBGAaK7M77dLS2lIq8YePE1PgLLq3KI1tTmetBzUAN7tzZPOHHGstPFQlCqI3SgD13J5Bd0kFdfksm3ZewaODTMSWE6iW5MnRQLb8WYBOduMV18T6x14NihrDX0XYZCT2BRPRT6uWTaUThZVDp8iOJzbthjv1Ka6CJONQ4UqjXpJS1oVSNI7H8pT8Oqer1RD5rJiItKeK9WuRMU3FJX3uXI8q0NfJsdlrKXUEtvko8j22K1i0qaUREXhqT3VrVfJTUCfbW1suJ14M9CVRNQBQoVaE3ouJSWOvaVkIGHS1x+eyfEAnWJoEr53NZLWCUSL1W6XwkV8FuTJs5Fgv4I/feWeMKC0lWTorgouJgTLmXnY/jEeQkvhmGkiUVHLWjNqB2HjuKxy+/skgSqSdedL7TP9Pl2fT4liSTad337LfsJVXodrPFiSGu6mD6o/QKK6opcungQUT4w4Eabmrp5zXLNyNGoDauOtSvO4Riz5LXixu29VOD+brZjdSHd0agb/aTS4UXlFt/P9cXab8mZZw4vSo2Nmn4k7BcZBU1BU9DUKGgKmoKmCChoCpoaBU1BU9DUKGgKmhoFTUFT0NQoaAqa2i8DvRZOF9G/jnD0lKvvCDfpaIGBi87RKENBmxnX9ccf/4v4TAr/ROvp7e29Y/GsnufPVlefnY2+gQ301D86eD6K/lUoaFPQ//PHH/DpnIfCP2zLn1eR3TN9zlHvqmh4n4cCaL/wj4J2Cnp+jIBoaJjzszESdKsAurWJQbvdtYEeur9qA/oTevDbJ/TUnrNP1KMlK1XX3DWDfj50Zg6aQ489GyLuoB7NwxfvU98vuFpAv3nWO8RzT81Bw5n4xGtAN7lHcyV/ypXMdzC1JUPeEvT86urYEU89mnTn14izazxt9Qlp4/LOCjRKhb1c7+exsbs9wh2TQl3XvOUdc+0fB87Wv45STKWi6N+j8XyWcwxaTJjPsWd3jOfz6Bx5UvmUuxlBMzdR4By9rqfoswa9KlUmd2kLzjOecNLlcvlfY3DIbgk0PLS6OnrE30Ftzf07TQ+auc6CPxfLEHg9kXThhrklj36OOPfi+uQbCh7NDtp9NYf8OSV+UyiSH09FPbcXOu4PScibHnQpAnGjTSzsIFjny7cHWizvRrWFXjN69Foekc5flDDp4e/J8bDn1kEvr67+3eygeabyHZEev8DffiuftoU76o/RQ99Wibw3L+NFyM+4ZgfNMx1ZID0Mjsy4SyWGqx/0fRI0bPVIix5NH6OB7hXUd6nTmzrr6HkT0MAXx455KPMoaCCdRkkw5b+pbXq/GUMGZMfGvi0bgBaWSe/1QJn37Q0FjWtpID1eKNV0KU9ekJbXpDWgefkCy/1PtDMUZnkpDD591Sjob2rQ/Kiwy9Pm6wvNQDOeQio1/A8s9fQsf5pvRsymC/9c6/Dwa57aPw6aGgVNQVOjoCloCpoaBU1BU6OgKejmAd1K7ZcYBf2rQNNJTWM0BU2NgqagKWhqFDQFTY2CpqApaGr/D0CXMx9ytziazcwHz2+J6SAYTDc26gZBv6pH29zcsjq54NuwajZbu4Z1JZlUdJFBJbnS2KgbAx2RBVF4fiY+cXl+/le3qfpbfEQyQXhlSd7+sS/uwmVsZZ8tjQEla8lk9YOcleSEmeVIPQ6XWpaMa+nsJMRjHI26IdAgBCM5dFyWgQm1G+6cUDRnL/EgfVqBHB5LK/3L8hV3FteHzR/2rKtkIEXz1jPtSF1kdxcpWMTFLzVia3ajNgXNOPwYaSWmSBdhhaaBJwpHHSMt6F0D0KD/ZfV9ZQNVUNJIcV8FTa5R0G0EyMR2v0pVyMmoTUFXK5zT6RXgZdA/W5ZQPJhQiyKrQXe294EJY0SgB/oEW5D3Cui0xmsEHTu4Ek1+D+WLC6YR0CrNMZ9GvsnJqE1AM6feLUc/JwUp4t/Sxq7olYmfpIKsBrQqfu+SwpxE1LfU93qskdTUgy7zt2IE6CrLDrqJUfdva/UMI/aqZAaiZI+8KyubUbe9Ux8aHp7U27QDrd8RTp5ZYvkSCGyAHhlkvGNxeMVZdjE2uFFSQKt/kiKyuYVsU5zY/5kOHIte/i4wLXxLh0uCzH1QTpee6Rgbe3zgUkAnyaqirz+e0Cl0Wo3aHPRaDmRQ/R5b0knDsmbEArRP69G61wDFwROTsBEklNy68EtwG1JAPjABnSMU9LCkrKhwj2ZGF/bS6pR4iD3BZ6qDWpk9SPmaIemkUM1HbRE63OGHKw8eTBZsSb83jEw/CGFTLej+iVDohU8BfT7RHer+OmOWhDQHmF58Cc4XCwaDi7OMhDE2uwd/DyXQ6qx0EpuaIpT6jkW1Wa8kZ1gFUb3MDhx3D94vKPGxezuxQQU0clf21Bq0xagtQHOMPwcSneGSTXFnqEsJqt9frauO7iVeVXX8FSd7MEtFO3Uy/BNVcxnkl8WYWBaQVUeaNyjvuD18+KLs2RmWXYfZ8AX0DsUzgHYudymasx4HSvfWozatOjx+LO7bZu3TxhVAyEF5NzCjKe+IMqUGAXaQel0viYXs+rUG9JwRaOyxAWZK6kYQIDGfH2NZVwa5tldMgKQu+LUN6HoF2D2nWxCn2yx/Q8LQo1GEPt813v3FhG+JW8BCnT+EtPIV1XXtI+paqRal+1kJBogfi3LV7OAitvWPhqCxM7Oknv0ex4BV8X1ojgixB15IAW3r0XUr3ZciXhBgb6swtXn0tlngUHeIKgniFvSckbpAyxvSLePyTt0ZenHyfCSfKsUQzgPyFEyblTK3CJpnLkBKeSVcrgl0XMXMxCCKk+UHN0FW3nWBBgXNpPEs14HGgsEnxG2ylyz+rqDzqnuga3phWxUuXGoK6m2yIHxLCn87Br0p9KgOlO5h4UJuaOEIO9m8aG04Sw4aga7YgLYetVXoKG5C6AhfM9Yd+LSmMD7vtu9zdJ2Lj2wR36kXyuxAp1W3HIAWhJlFkVgoOgrG1cOxUkdndDNXB9p61BbJ0O+FZJh9bTkdCuqapq9f03yr5apVd7eY9ZLwrtKqRkA371Wgj1UsHIBGHV/sAyv5aEADCJXVgyWpSZC8aENHUdewZGwV2I3Luygu77I2LQtK0UQ67kP8Qgvk40vGoFEg7+8js+MTosW5Vh1TL8C+Q27mpDNdFYXV7UGDkv0JcBGe6GLVStNQvmBibqWO1jqU8M5U70s9aseg3VGIzw/Ddt8FB3/7Lm206zhrBdg7hQ7Qhxz/CXLgBbFFxELscaI0nuUsQHvJYAjUkuJuOBcZgz5W3K00hZ/fui5ihHrwlQDxz+mI4Mgv3YKry6BhFbSqTjMD6sJJPWrHq3dzwHnSgdZ9ARf5SjvS3x0SbMYANAoQ3Z3x7W5p/Rl5xcCLr/ERWN6VQ7SmNteDnoMa2Lu1ecKJM5adLhaCUh2hA33oSia/oIO8+pJMvi1j18ChYU4K00l0Y+qkWHgrxiQ4d4vp4ntirQPHDmWtoe8yFIJld/Tv55JVj2y7qHT4EMXn3LDHfqU00SWfagD917l6rXZJC1rVCOJHxQsB8jSsqhcE9aCZjLiohPdqlTtBwS115V2OLN/awLfZYSl7CbX0Jvk4si1Wu6ikGRVxYUh6b1X7VVIj0FdbKyteB/4sVDUBpRhWBrBkFDoupaWOfSVk4L2Jy2/vhFigLhFUKZ/begmrROKlSvcroQJ+a9LEuUjQH6H/3hJPWFC6alIUFwUXc8Kl7HwMnzgv4cUwjDRZW2lAa0btOHQUj11+Z5ckUE267nyhfabPt+vzKUkk0b7r22/ZT6jS62CNF0Na08X0QWOqF5V08SCifGDAjTY1dfOa5ZqRo1EbVh1rV05/TilLXitu3N5LBe7vZjtWF9IdjbrRTyodXtzmbz9fX6z9lpx55vCi1Nio6UfCfpFR0BQ0BU2NgqagKWiKgIKmoKlR0BQ0BU2NgqagqVHQFDQFTY2CpqCpUdAUNAVdl62F00X0ryMcPa1Tye0mHS0w8DGKaJShoM1ML1c9NHoGSkJP582eMvpcsl58aiYF5fXmlasWzG39WVKdAPuorN80ZiwdxH2W9/iGdQ2p0j1Yqbrmrgk0Vhy7/0zhqHvGUwPQza10z8MX71PfL7jaQP99b4jn75xJYslGoHvvCMZTjxaYlPwpVzJvpYKqA/1JVOY8+hvF6SMT0Kr4TT2aeY04u8bTnlpAy9ZrIt2rE/5teo9mrv2gG5mu1BQ6ZHtuAXqZejTB+QbkwMej1zWWdwTou2Yx+v7Z2NhdifakUNc1a3nHeEDb1+XHaoYcMpMnFlOpKPr3aDyfVe3SYybdq1QdTwXB+47xfB6dI08qn3I3H2jmOgv+XCyDm3oi6cJNbV0bVMu25d39oaZvwd1Xc6BVLX5TKJIfT0Vr+2lF0Eg2lu7l7p4tD3Fv5qF9fN70oEsRiBttYmEHwTpf049Bjdprfh99bkqX1nr0Wh6Rzl8IStXD35Pj4Vo8+p4Tb4UovtzsoHmm8h2RHr/A334rn7aFO2qI0aBhf9d2Le/NN01B3ZSgeaYjC6SHwZEZd6nEOF8EBSn7syP7fPmUgsakr6C+S53e1Hqonvurq59JzjoBdvHu+xS0SDoNOvf+m9oW9O8gfmNvtEQNQI8a3dmcax3XQHq8UGIa4qwBfa9XKDXm0b3PjihoHEVLYfDpqxpA43bk/ucxwYYMQPeilrB3dBS3LfM8BY2pMZ5CKjVcS2NM9H0yXB1oyXp5Clri1jo8/Lqm1vsuCXrIIBnilhDscw9PQf+jNtSz/Gl5/g7PU9DUKGgKmhoFTUFT0NQoaAqaGgVNQVPQ1P4p0K3UfolR0L8KNJ3UNEZT0NQoaAqagqZGQVPQ1Cjo/1LQ5cyH3C2OZjPzwfNbYjoIBtONjbpB0K/q0TY3t6yhXHCjVs1ma9ewriSTii4yqCRXGht1Y6AjsiAKn9jt7L48P/+ru8XsQ6jxEckE4ZUlefvHvrgLl7GVfbY0BpSsJZPVD3JWkhNmliP1OFxqWTKupbOTEI9xNOqGQIMQjOTQiuDOk3bDnROK5qwgSktI9MhicHOSDI3ZK+4srg+bP+xZV8lAiuatZ9qRusjuLlKwiItfasTW7EZtCppz+MnoSkyRLsKCO09+Yu3eBcODakHvGoAG/S+rb3caCwrLRor7KmhyjYJuI0AmtvtVqkJORm0K+qqDczq9AtLtvp/bfQjwzIhaFFkNurO9D6xdOjUDfYIpZyZgqDVeA+jYwZVo8nsoX1wwjYBWaY75NPJNTkZtApqJuJKnTkYGKeLfOhQTFgLsKr3IXVKYk4j6lvpejzWSmnrQZf5WjABdZdlBNzHq/m2tnmHEXpXM4DssleOVla1ht71THxoeXqUgawNavyOcPLPE8iUQ2AA9Msh4x+LwirPsYmxwo6SAVn+BP7K5hWxTnNj/mQ4ci17+LjAtfEuHS4LMfVBOl57pGBt7fOBSQCfJqqKvP57QKXRajdoUdOkCZPY2ix5b0knDsqZTI4hKgvZpPVr3GqA4eGISNoKEklsXfgluQwrIByagc4SCHpaUFRXu0czowl5anRIPsSf4THVQK7MHKV8zJJ0UqvmoLUKHOzsJAp32H/h/bxSZ9vstYnT/RCj0wkekz4nuUPfXGbMkpDnA9OJLcL5YMBhcnGUkjLHZPfh7KIFWZ6WT2NQUodR3LKrNeiU5wyqI6mV24Lh7cNZBiY/d24kNKqCRu7Kn1qAtRm0BmiulsRRqumRT3Gl1KWdaWuIvzjXy6gZVR/cSr6o6/oqTPZilop06Gf6JqrkM8odiTCwLyKojzRuUd9wePnxR9uwMy67DbPgCeofiGUA7l7sUzVmPA6V761GbVh1lQdx3zjp66CoAn4qjRXk3MKMp74gpUIMAO0i9rpfEQnb9WgN6zgg09tgAMyV1IwiQmM+Psawrg1zbKyZAUhf82gZ0vQLsZSdy1TqPFkGHjBsW7sWEb4lbwEKdP4S08hXVde0j6lqpFqX7WQkGiB+LctXs4CK29Y+GoLEzs6Se/R7HgFXxfWiOCLEHXkgBbevRdSvdl4ZzWIDd8vertB6NQkcLDh19Vq8IHaIquLSgp4zUBVrekG4Zl3fqztCLk+cj+VQphnAekKdg2qyUuUXQPHMBcXolXK61eQB5cMOqQ9njXF1+QOWtPKMu0KCgmTSe5TrQWDD4hLhN9pLF3xV0Xn/3vlk2lGzhUlNQqyrvt6Twt2PQm0KP6kDpHhYuFElidISdbF60NpwlB41AV2xAW4/aKnREvBA62iqMdQduUNMsofpu1zKJajsXH9kivlMvlNmBTqtuOQAtCDOLIrFQdBSMq4djpY7O6GauDrT1qM1Be063UDKcbLP+QaWCYU0DoFuk4WjWBOS7WzQtjuzR8K7SqkZAN+9VoI9VLByARh1f7AMr+WhAAwiV1YMlqUmQvGhDR1HXsGRsFdgNQXv8Xiik22yaQ5SiDcSqfXI2XDIGHdeky8QTYnXkWnVMvQD7DrmZk850VRRWtwcNSvYnwEV4ootVK01D+YKJuZU62sChtGsd1+u2st2Gv24QzSHOk+GS3XI08rfv0u0f2zNyMhTXSTUC7J3CDj7k8U+QAy+ILSIWYo8TpfEsZwHaSwZDoJYUd8O5yBj0seJupSn8/NZ1ESPUg68EiH9ORwRHfukWXF0GDaugVXWaGVDnIfWoHa/ehR+i+Dzpt1/sKOAiXw683Z3x7Qmi/1CD7hR26JbWn5FXDLz4Gh+B5V05RGtqcz3oOaiBvVubJ5w4Y9npYiEo1RE60IeuZPILOsirL8nk2zJ2DRwa5qQwnUQ3pk6KhbdiTIJzt5guvifWOnDsUNYa+i5DoSewqB4K/Vwy6SgcgXYfwqLSw1N7znyiSznVIaXPm0jwBqGjU9MI4kfFCwHyNKyqFwT1oJmMuKiE92qVO0HBLXXlXY4s39rAt9lhKXsJtfQm+TiyLVa7qKQZFXFhSHpvVftVUsOf+tlaWfH63U7W/t8qK/9xifSTFjLrEaHjUlrq2FdCBh4ucfntnRAL1CWCKuVzWy9hlUi8VOl+JVTAb02aOBcJ+iP031viuwxKV02K4qLgYk64lJ2P4RPnJbwYhpHmyUtJatCaUTsOHcPHLr+zSxKoJlXeWKLPh6zdfO+ZPt8uuUOifde337KfUKXXwRovhrSmi+mDxjQCKuniQUT5wIAbbWrq5jXLNSNHozasOtaunP6cUpa8Vty4vZcK3N/NdqwupDsadaOfVDq8uM1fyr2+WPstOfPM4UWpsVHTj4T9IqOgKWgKmhoFTUFT0BQBBU1BU6OgKWgKmhoFTUFTo6ApaAqaGgVNQVOjoCloCrouWwuni+hfRzh6ytV3hJt0tMDAxyiiUYaCNjOduO/Rp94zUFp5es+M++hzyXrxLpOCTnWzivs6Ba2Vq16W5W6eGSutgBqtaIIoLVW6x1by1Ab6E2b8NxYWemP4jKcGoJtb6R6o3BStv6OsA93z9+gdBHjouZkWFoDuvSMYTz1aMMYTHU+dWn2g1FTpnjuzEGBXqb5Rj+Y5LMI+fuWuAzToQv59ZAL6nhZ0c3s004E5++vyaJDT+2wGepl6NMn5Kmwvhaor7yQD5VnTGH3/bGzsrkR7Uqjrmra8E8R9v5/ayBkWU6ko+vdoPJ+VTsjQvfl7d1fN5NWVquOp8HjHeD6PzpEnlU+5mw80x1RIuWpPLbqzYin91KSOfqoVlmzqFpyppAQBdtgAAfZrplbQn01A3z1bHuLeYKHO500P2r2WR5zzgtA9P/w9OR52/huWcuiw1Do9+tyULq0BXYogzq428dcjoigp5mv81a0730yqDiVdrmrKj6b06CuI0KlhDyYdyY+norX+KmuPncO++UaV7kF8vQ1idBGT9kTChdZalzBBpPqT5TLJUwoad99Q3bn8ZVyCMEzNi80AWuColqs22KGpQHNaY66j4NPRClefLUM2xLdEAXbtDqNGd/7Xmx40qqQhCY6nK0wNxzl6PjqEb0BneP+NAeh7vcIO8+jeZ28oaCDdKpD21ED6CAXep72jo2dQSfdyBqB7hR1w2zLPUdDYPEA6VYtLHynXT1bPGBPQkvVyFLTo025/KlWsJXRwo2PSlax70l1iMhS3cEuIO8cejoKWSXvWDks1HurNnU/Ly/MWaW6oZ/mT5Q5NCBpFDw9H7VeApkZBU9DUKGgKmoKmRkFT0NRM7f8EGAB+99eEifoz3AAAAABJRU5ErkJggg==" alt=""><br>
实际上，toFixed 函数对于四舍五入的规则与数学中的规则不同，而且并不是使用的网上所说的银行家舍入规则（四舍六入五考虑，五后非零就进一，五后为零看奇偶，五前为偶应舍去，五前为奇要进一），而是有一定的规则，具体可以查看这篇文章：<a href="https://juejin.cn/post/6927215610552123406" target="_blank" rel="noopener noreferrer">toFixed四舍五入的不准确性<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>。其实 toFixed 不准确的根本原因是精度问题，比如：1.005.toFixed(2) 返回的是 1.00 而不是 1.01，原因： 1.005 实际对应的数字是 1.00499999999999989，在四舍五入时全部被舍去！具体查看：<a href="https://github.com/camsong/blog/issues/9" target="_blank" rel="noopener noreferrer">JavaScript 浮点数陷阱及解法<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p>很显然，这并不是我们想要的结果。我们可以用浏览器提供的 Intl.NumberFormat 构造函数来格式化数字，它有很好的浏览器支持（包括 IE11），这里我封装一个四舍五入的方法</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// minimumFractionDigits 和 maximumFractionDigits 分别代表最小和最大小数位数，例如分别取 2，3，则 format(1.1) 则为 1.10，format(1.1111) 则为 1.111</span>
<span class="token keyword">function</span> <span class="token function">roundFloat</span> <span class="token punctuation">(</span><span class="token parameter">value<span class="token punctuation">,</span> decimal <span class="token operator">=</span> <span class="token number">2</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> formatter <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Intl<span class="token punctuation">.</span>NumberFormat</span><span class="token punctuation">(</span><span class="token string">'en-US'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>
    minimumFractionDigits<span class="token operator">:</span> decimal<span class="token punctuation">,</span>      
    maximumFractionDigits<span class="token operator">:</span> decimal<span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> formatter<span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="commonjs-和-es6-的区别"><a href="#commonjs-和-es6-的区别" class="header-anchor">#</a> commonjs 和 es6 的区别</h2> <p>CommonJS 是一种模块规范，最初被应用于 Nodejs，成为 Nodejs 的模块规范。运行在浏览器端的 JavaScript 由于也缺少类似的规范，在 ES6 出来之前，前端也实现了一套相同的模块规范 (例如: AMD)，用来对前端模块进行管理。自 ES6 起，引入了一套新的 ES6 Module 规范，在语言标准的层面上实现了模块功能，而且实现得相当简单，有望成为浏览器和服务器通用的模块解决方案。但目前浏览器对 ES6 Module 兼容还不太好，我们平时在 Webpack 中使用的 export 和 import，会经过 Babel 转换为 CommonJS 规范。在使用上的差别主要有：</p> <ol><li>CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。</li> <li>CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。</li> <li>CommonJs 是单个值导出，ES6 Module可以导出多个。</li> <li>CommonJs 是动态语法可以写在判断里，ES6 Module 静态语法只能写在顶层。</li> <li>CommonJs 的 this 是当前模块，ES6 Module的 this 是 undefined。</li></ol> <p>关于区别二的证明代码如下：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// lib.js</span>
<span class="token keyword">var</span> counter <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>
<span class="token keyword">function</span> <span class="token function">incCounter</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  counter<span class="token operator">++</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>
  counter<span class="token operator">:</span> counter<span class="token punctuation">,</span>
  incCounter<span class="token operator">:</span> incCounter<span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// main.js</span>
<span class="token keyword">var</span> mod <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'./lib'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>mod<span class="token punctuation">.</span>counter<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 3</span>
mod<span class="token punctuation">.</span><span class="token function">incCounter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>mod<span class="token punctuation">.</span>counter<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 3</span>
</code></pre></div><p>实际 counter 在输出的时候是一个拷贝，再看看 ES6 Module：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// lib.js</span>
<span class="token keyword">export</span> <span class="token keyword">let</span> counter <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>
<span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">incCounter</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  counter<span class="token operator">++</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// main.js</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span> counter<span class="token punctuation">,</span> incCounter <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'./lib'</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>counter<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 3</span>
<span class="token function">incCounter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>counter<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 4</span>
</code></pre></div><p>上面代码说明，ES6 模块输入的变量counter是活的，完全反应其所在模块lib.js内部的变化。</p> <p>参考：<a href="https://es6.ruanyifeng.com/#docs/module-loader#ES6-%E6%A8%A1%E5%9D%97%E4%B8%8E-CommonJS-%E6%A8%A1%E5%9D%97%E7%9A%84%E5%B7%AE%E5%BC%82" target="_blank" rel="noopener noreferrer">ES6 模块与 CommonJS 模块的差异
<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <h2 id="什么是循环依赖"><a href="#什么是循环依赖" class="header-anchor">#</a> 什么是循环依赖？</h2> <p>&quot;循环加载&quot;（circular dependency）指的是，a脚本的执行依赖b脚本，而b脚本的执行又依赖a脚本。目前前端主要有两种加载模式方式，分别是：CommonJS 和 ES6 模块加载，webpack 在打包的时候会根据配置模拟两种加载模式去加载。</p> <ol><li>CommonJS 模块加载
CommonJS 模块的重要特性是加载时执行，即脚本代码在require的时候，就会全部执行。CommonJS 的做法是，一旦出现某个模块被&quot;循环加载&quot;，就只输出已经执行的部分，还未执行的部分不会输出。</li> <li>ES6 模块加载
ES6 模块的运行机制与 CommonJS 不一样，它遇到模块加载命令import时，不会去执行模块，而是只生成一个引用。等到真的需要用到时，再到模块里面去取值。ES6 根本不会关心是否发生了&quot;循环加载&quot;，只是生成一个指向被加载模块的引用，需要开发者自己保证，真正取值的时候能够取到值。</li></ol> <p>tips：建议阅读阮一峰的文章 <a href="http://www.ruanyifeng.com/blog/2015/11/circular-dependency.html" target="_blank" rel="noopener noreferrer">http://www.ruanyifeng.com/blog/2015/11/circular-dependency.html<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <h2 id="session、cookie、token-和-jwt-的区别"><a href="#session、cookie、token-和-jwt-的区别" class="header-anchor">#</a> session、cookie、token 和 jwt 的区别</h2> <p>它们出现的原因是因为 http 是无状态的，所以需要一种手段去标示哪些 http 请求是那个用户发送的。</p> <ol><li>session 存储于服务器，可以理解为一个状态列表，拥有一个唯一识别符号 sessionId，通常存放于 cookie 中。服务器收到 cookie 后解析出 sessionId，再去 session 列表中查找，才能找到相应 session。所以 session 的实现依赖于 cookie。</li> <li>cookie 类似一个令牌，装有 sessionId，存储在客户端，浏览器通常会自动添加，存储大小为 4kb。</li> <li>token 也类似一个令牌，无状态，用户信息都被加密到 token 中，服务器收到 token 后解密就可知道是哪个用户。需要开发者手动添加。</li> <li>jwt 是一个跨域认证的方案</li></ol> <h2 id="dom-事件触发流程"><a href="#dom-事件触发流程" class="header-anchor">#</a> DOM 事件触发流程</h2> <ol><li>捕获阶段：从父节点到目标节点</li> <li>目标阶段：在目标元素上触发事件</li> <li>冒泡阶段：从目标节点到父节点</li></ol> <h2 id="target-和-currenttarget-区别"><a href="#target-和-currenttarget-区别" class="header-anchor">#</a> target 和 currentTarget 区别</h2> <ul><li>event.target<br>
返回触发事件的元素（例如用户点击时会返回点击位置最底层的 dom 元素）</li> <li>event.currentTarget<br>
返回绑定事件的元素</li></ul> <h2 id="什么是事件委托"><a href="#什么是事件委托" class="header-anchor">#</a> 什么是事件委托</h2> <p>事件委托利用了事件冒泡，只指定一个事件处理程序，就可以管理某一类型的所有事件。使用事件委托的一个好处就是可以节省内存。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token operator">&lt;</span>ul<span class="token operator">&gt;</span>
  <span class="token operator">&lt;</span>li<span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span>span<span class="token operator">&gt;</span>苹果<span class="token operator">&lt;</span><span class="token operator">/</span>span<span class="token operator">&gt;</span>
  <span class="token operator">&lt;</span><span class="token operator">/</span>li<span class="token operator">&gt;</span>
  <span class="token operator">&lt;</span>li<span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span>span<span class="token operator">&gt;</span>香蕉<span class="token operator">&lt;</span><span class="token operator">/</span>span<span class="token operator">&gt;</span>
  <span class="token operator">&lt;</span><span class="token operator">/</span>li<span class="token operator">&gt;</span>
  <span class="token operator">&lt;</span>li<span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span>span<span class="token operator">&gt;</span>凤梨<span class="token operator">&lt;</span><span class="token operator">/</span>span<span class="token operator">&gt;</span>
  <span class="token operator">&lt;</span><span class="token operator">/</span>li<span class="token operator">&gt;</span>
<span class="token operator">&lt;</span><span class="token operator">/</span>ul<span class="token operator">&gt;</span>

<span class="token comment">// good</span>
document<span class="token punctuation">.</span><span class="token function">querySelector</span><span class="token punctuation">(</span><span class="token string">'ul'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function-variable function">onclick</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">event</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> target <span class="token operator">=</span> event<span class="token punctuation">.</span>target
  <span class="token keyword">while</span> <span class="token punctuation">(</span>target<span class="token punctuation">.</span>nodeName <span class="token operator">!==</span> <span class="token string">'UL'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 这里捕获 li 元素</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>target<span class="token punctuation">.</span>nodeName <span class="token operator">===</span> <span class="token string">'LI'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">break</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    target <span class="token operator">=</span> target<span class="token punctuation">.</span>parentNode<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token comment">// bad</span>
document<span class="token punctuation">.</span><span class="token function">querySelectorAll</span><span class="token punctuation">(</span><span class="token string">'li'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  e<span class="token punctuation">.</span><span class="token function-variable function">onclick</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>innerHTML<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span> 
</code></pre></div><p>最后说一下其实在 Vue 和 React 里大多数情况是不需要事件代理的，只要保证 for 循环绑定的是一个函数就不会有内存浪费的问题。而且 React 有自己的一套事件机制（在 React17 之前，React 是把事件委托在 document 上的，React17 及以后版本不再把事件委托在 document 上，而是委托在挂载的容器上），我们使用的都是由 React 合成的事件，React 内部会把所有的事件绑定到 document 上，采用的就是事件代理的思想，在框架层面已经帮我们优化了。</p> <h2 id="prototype-和-proto-的关系是什么"><a href="#prototype-和-proto-的关系是什么" class="header-anchor">#</a> prototype 和 <code>__proto__</code> 的关系是什么</h2> <p>结论：</p> <ol><li><code>prototype</code> 用于访问函数的原型对象。</li> <li><code>__proto__</code> 用于访问对象实例的原型对象（值得注意的是这个属性是非标准的，只不过各浏览器都实现了它，推荐使用 es6 标准的 Object.getPrototypeOf() 来获取原型对象）。</li></ol> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">Test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token keyword">const</span> test <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Test</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
test<span class="token punctuation">.</span>__proto__ <span class="token operator">==</span> <span class="token class-name">Test</span><span class="token punctuation">.</span>prototype <span class="token comment">// true</span>
</code></pre></div><p>也就是说，函数拥有 prototype 属性，对象实例拥有 <code>__proto__</code> 属性，它们都是用来访问原型对象的。<br>
最后贴一个图，有助于理解：
<img src="/Front-end-interview/assets/img/js_prototype.0c8883d6.jpg" alt=""></p> <h2 id="原型链"><a href="#原型链" class="header-anchor">#</a> 原型链</h2> <p>所有的 JS 对象都有一个 <code>__proto__</code> 属性，指向它的原型对象。当试图访问一个对象的属性时，如果没有在该对象上找到，它还会搜寻该对象的原型，以及该对象的原型的原型，依次层层向上搜索，直到找到一个名字匹配的属性或到达原型链的末尾（末尾是 null）。</p> <h2 id="闭包"><a href="#闭包" class="header-anchor">#</a> 闭包</h2> <p>闭包是指有权访问另一个函数作用域中的变量的函数。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">sayName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> name <span class="token operator">=</span> <span class="token string">'xiaoming'</span>

  <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">Hi! </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>name<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">const</span> test <span class="token operator">=</span> <span class="token function">sayName</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// Hi! xiaoming</span>
</code></pre></div><p>虽然 sayName 函数已经执行完毕，但是其活动对象也不会被销毁，因为 test 函数仍然引用着 sayName 函数中的变量 name，这就是闭包。但也因为闭包引用着另一个函数的变量，导致另一个函数即使不使用了也无法销毁，所以闭包使用过多，会占用较多的内存，这也是一个副作用。</p> <h2 id="内存回收"><a href="#内存回收" class="header-anchor">#</a> 内存回收</h2> <p>在 JS 中，有两种内存回收算法。第一种是引用计数垃圾收集，第二种是标记-清除算法（从2012年起，所有现代浏览器都使用了标记-清除垃圾回收算法）。</p> <h3 id="引用计数垃圾收集"><a href="#引用计数垃圾收集" class="header-anchor">#</a> 引用计数垃圾收集</h3> <p>如果一个对象没有被其他对象引用，那它将被垃圾回收机制回收</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> o <span class="token operator">=</span> <span class="token punctuation">{</span> a<span class="token operator">:</span> <span class="token number">1</span> <span class="token punctuation">}</span>
</code></pre></div><p>一个对象被创建，并被 o 引用。</p> <div class="language-js extra-class"><pre class="language-js"><code>o <span class="token operator">=</span> <span class="token keyword">null</span>
</code></pre></div><p>刚才被 o 引用的对象现在是零引用，将会被回收。</p> <h4 id="循环引用"><a href="#循环引用" class="header-anchor">#</a> 循环引用</h4> <p>引用计数垃圾收集有一个缺点，就是循环引用会造成对象无法被回收。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token keyword">var</span> o <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token keyword">var</span> o2 <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
  o<span class="token punctuation">.</span>a <span class="token operator">=</span> o2<span class="token punctuation">;</span> <span class="token comment">// o 引用 o2</span>
  o2<span class="token punctuation">.</span>a <span class="token operator">=</span> o<span class="token punctuation">;</span> <span class="token comment">// o2 引用 o</span>

  <span class="token keyword">return</span> <span class="token string">&quot;azerty&quot;</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>在 f() 执行后，函数的局部变量已经没用了，一般来说，这些局部变量都会被回收。但上述例子中，o 和 o2 形成了循环引用，导致无法被回收。</p> <h3 id="标记-清除算法"><a href="#标记-清除算法" class="header-anchor">#</a> 标记-清除算法</h3> <p>这个算法假定设置一个叫做根（root）的对象（在 Javascript 里，根是全局对象）。垃圾回收器将定期从根开始，找所有从根开始引用的对象，然后找这些对象引用的对象……从根开始，垃圾回收器将找到所有可以获得的对象和收集所有不能获得的对象，之后会清除掉所有不能获得的对象。</p> <p>对于刚才的例子来说，在 f() 执行后，由于 o 和 o2 从全局对象出发无法获取到，所以它们将会被回收。</p> <h3 id="高效使用内存"><a href="#高效使用内存" class="header-anchor">#</a> 高效使用内存</h3> <p>在 JS 中能形成作用域的有函数、全局作用域、with，在 es6 还有块作用域。局部变量随着函数作用域销毁而被释放，全局作用域需要进程退出才能释放或者使用 delete 和赋空值 <code>null</code> <code>undefined</code>。</p> <p>在 V8 中用 delete 删除对象可能会干扰 V8 的优化，所以最好通过赋值方式解除引用。</p> <p>参考资料：<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Memory_Management" target="_blank" rel="noopener noreferrer">内存管理<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <h2 id="对象浅拷贝和深拷贝有什么区别"><a href="#对象浅拷贝和深拷贝有什么区别" class="header-anchor">#</a> 对象浅拷贝和深拷贝有什么区别</h2> <p>在 JS 中，除了基本数据类型，还存在对象、数组这种引用类型。对于基本类型，浅拷贝和深拷贝都会拷贝它的值。对于引用类型，浅拷贝只会拷贝它的地址，而深拷贝会创建一个一样的对象。<br>
浅拷贝：Object.assign，扩展运算符等。<br>
深拷贝：JSON.parse(JSON.stringify(obj))（不过这个方法会有很多坑，详见：<a href="https://www.jianshu.com/p/b084dfaad501" target="_blank" rel="noopener noreferrer">https://www.jianshu.com/p/b084dfaad501<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>），浏览器原生支持的 structuredClone API，lodash 的 cloneDeep 方法等。</p> <h2 id="javascript-里的类型判断"><a href="#javascript-里的类型判断" class="header-anchor">#</a> javascript 里的类型判断</h2> <ol><li>判断 Null 和 Undefined<br>
使用全等 === 来判断</li> <li>判断 Boolean、Number、String、BigInt、Symbol、Function<br>
使用 typeof 操作符来判断，它会返回构造函数的小写名称，不过对于数组和对象都会返回 object</li> <li>判断数组<br>
使用 Array.isArray 静态方法来判断，会返回布尔值</li> <li>判断 Promise</li></ol> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">isDef</span> <span class="token punctuation">(</span><span class="token parameter">val</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> val <span class="token operator">!==</span> <span class="token keyword">undefined</span> <span class="token operator">&amp;&amp;</span> val <span class="token operator">!==</span> <span class="token keyword">null</span>
<span class="token punctuation">}</span>
<span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">isPromise</span> <span class="token punctuation">(</span><span class="token parameter">val</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token punctuation">(</span>
    <span class="token function">isDef</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>
    <span class="token keyword">typeof</span> val<span class="token punctuation">.</span>then <span class="token operator">===</span> <span class="token string">'function'</span> <span class="token operator">&amp;&amp;</span>
    <span class="token keyword">typeof</span> val<span class="token punctuation">.</span>catch <span class="token operator">===</span> <span class="token string">'function'</span>
  <span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><ol start="5"><li>判断对象、RegExp、Date 等<br>
使用 Object.prototype.toString.call 这个万能方法，它会返回 [object type] 字符串，type 就是对应的类型</li></ol> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 纯对象</span>
<span class="token class-name">Object</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span> <span class="token operator">===</span> <span class="token string">'[object Object]'</span>
<span class="token comment">// RegExp</span>
<span class="token class-name">Object</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>reg<span class="token punctuation">)</span> <span class="token operator">===</span> <span class="token string">'[object RegExp]'</span>
<span class="token comment">// Date</span>
<span class="token class-name">Object</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>date<span class="token punctuation">)</span> <span class="token operator">===</span> <span class="token string">'[object Date]'</span>
</code></pre></div><ol start="6"><li>判断构造函数的原型是否在对象的原型链上<br>
使用instanceof 操作符</li></ol> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">Fruit</span><span class="token punctuation">(</span><span class="token parameter">name<span class="token punctuation">,</span> color</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>color <span class="token operator">=</span> color<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> apple <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Fruit</span><span class="token punctuation">(</span><span class="token string">&quot;apple&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;red&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

apple <span class="token keyword">instanceof</span> <span class="token class-name">Fruit</span>  <span class="token comment">// true</span>
apple <span class="token keyword">instanceof</span> <span class="token class-name">Array</span>   <span class="token comment">// false</span>
</code></pre></div><h2 id="javascript-有哪些数据类型"><a href="#javascript-有哪些数据类型" class="header-anchor">#</a> javascript 有哪些数据类型</h2> <ol><li>Undefined</li> <li>Null</li> <li>Boolean</li> <li>Number</li> <li>String</li> <li>Object</li> <li>Symbol</li> <li>BigInt</li></ol> <h2 id="内置对象和函数"><a href="#内置对象和函数" class="header-anchor">#</a> 内置对象和函数</h2> <p>包括许多构造函数，例如 String、Array 等，还包括一些工具对象和函数：Intl、JSON、Math，具体查看：<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects" target="_blank" rel="noopener noreferrer">JavaScript 标准内置对象<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p>注意像 String、Number、Boolean 我们定义的时候一般不会使用 new 的方式，而是使用定义字面量的方式定义。例如 &quot;i am string&quot;，当我们调用它的字面量的方法时，语法编译器会自动进行装箱操作，将其包装成 String 对象，然后调用其方法，之后再进行拆箱操作将其转回字面量。</p> <h2 id="cookie、localstorage、sessionstorage区别"><a href="#cookie、localstorage、sessionstorage区别" class="header-anchor">#</a> cookie、localStorage、sessionStorage区别</h2> <table><thead><tr><th>特性</th> <th>cookie</th> <th>localStorage</th> <th>sessionStorage</th></tr></thead> <tbody><tr><td>由谁初始化</td> <td>客户端或服务器，服务器可以使用<code>Set-Cookie</code>请求头</td> <td>客户端</td> <td>客户端</td></tr> <tr><td>数据的生命周期</td> <td>一般由服务器生成，可设置失效时间。在浏览器生成，默认失效时间是关闭浏览器之后失效</td> <td>永久保存，可清除</td> <td>仅在当前会话有效，关闭页面后清除</td></tr> <tr><td>存放数据大小</td> <td>4KB</td> <td>5MB</td> <td>5MB</td></tr> <tr><td>与服务器通信</td> <td>每次都会携带在HTTP头中（Secure 和 SameSite 会影响是否携带），如果使用cookie保存过多数据会带来性能问题</td> <td>仅在客户端保存</td> <td>仅在客户端保存</td></tr> <tr><td>用途</td> <td>一般由服务器生成，用于标识用户身份</td> <td>用于浏览器缓存数据</td> <td>用于浏览器缓存数据</td></tr> <tr><td>访问权限</td> <td>任意窗口</td> <td>任意窗口</td> <td>当前页面窗口</td></tr> <tr><td>作用范围</td> <td>可以设置 二级、三级 域名携带，设置二级域名会使所有匹配的三级域名携带 cookie</td> <td>只能在当前域名携带</td> <td>只能在当前域名携带</td></tr></tbody></table> <h2 id="请简述-javascript-中的-this"><a href="#请简述-javascript-中的-this" class="header-anchor">#</a> 请简述 JavaScript 中的 this</h2> <p>this 取值符合以下规则：</p> <ol><li>在调用函数时使用 new 关键字，函数内的 this 是一个全新的对象。</li> <li>如果 apply、call 或 bind 方法用于调用、创建一个函数，函数内的 this 就是作为参数传入这些方法的对象。</li> <li>当函数作为对象里的方法被调用时，函数内的 this 是调用该函数的对象。比如当 <code>obj.method()</code> 被调用时，函数内的 this 将绑定到 obj 对象。</li> <li>如果调用函数不符合上述规则，那么 this 的值指向全局对象（global object）。浏览器环境下 this 的值指向 window 对象，但是在严格模式下('use strict')，this 的值为 undefined。</li> <li>如果符合上述多个规则，则较高的规则（1 号最高，4 号最低）将决定 this 的值。</li> <li>如果该函数是 ES2015 中的箭头函数，将忽略上面的所有规则，this 被设置为它被创建时的上下文。</li></ol> <h2 id="window-onload-和-domcontentloaded-的区别"><a href="#window-onload-和-domcontentloaded-的区别" class="header-anchor">#</a> window.onload 和 DOMContentLoaded 的区别</h2> <p>当整个页面及所有依赖资源如样式表和图片都已完成加载时，将触发load事件。</p> <p>它与 DOMContentLoaded不同，当纯 HTML 被完全加载以及解析时，DOMContentLoaded 事件会被触发，而不必等待样式表，图片或者子框架完成加载。</p> <h2 id="object-与-map-的区别"><a href="#object-与-map-的区别" class="header-anchor">#</a> Object 与 Map 的区别</h2> <ol><li>Object 只能选择字符、数值、符号作为 key。Chrome 中使用 for-in 语句遍历 Object 属性时会遵循一个规律：首先遍历所有数值键（如果能转成数字的话），按照数值升序排列。其次遍历所有字符串键，按照加入时间升序排列。最后遍历所有 Symbol 键，按照加入时间升序排列。</li> <li>Map 可以使用任何类型的数据作为 key，Map 实例内部会维护键值对的插入顺序，因此可以根据插入顺序执行迭代操作。</li></ol> <h3 id="选择-object-还是-map"><a href="#选择-object-还是-map" class="header-anchor">#</a> 选择 Object 还是 Map</h3> <p>对于多数Web开发任务来说，选择 Object 还是 Map 只是个人偏好问题，影响不大。不过，对于在乎内存和性能的开发者来说，对象和映射之间确实存在显著的差别。</p> <h4 id="_1-内存占用"><a href="#_1-内存占用" class="header-anchor">#</a> 1. 内存占用</h4> <p>Object 和 Map 的工程级实现在不同浏览器间存在明显差异，但存储单个键/值对所占用的内存数量都会随键的数量线性增加。批量添加或删除键/值对则取决于各浏览器对该类型内存分配的工程实现。</p> <p>不同浏览器的情况不同，但给定固定大小的内存， Map 大约可以比 Object 多存储 50% 的键/值对。</p> <h4 id="_2-插入性能"><a href="#_2-插入性能" class="header-anchor">#</a> 2. 插入性能</h4> <p>向 Object 和 Map 中插入新键/值对的消耗大致相当，不过插入Map 在所有浏览器中一般会稍微快一点儿。对这两个类型来说，插入速度并不会随着键/值对数量而线性增加。</p> <p>如果代码涉及大量插入操作，那么显然 Map 的性能更佳。</p> <h4 id="_3-查找速度"><a href="#_3-查找速度" class="header-anchor">#</a> 3. 查找速度</h4> <p>与插入不同，从大型 Object 和 Map 中查找键/值对的性能差异极小，但如果只包含少量键/值对，则 Object 有时候速度更快。在把 Object 当成数组使用的情况下（比如使用连续整数作为属性），浏览器引擎可以进行优化，在内存中使用更高效的布局。</p> <p>这对 Map 来说是不可能的。对这两个类型而言，查找速度不会随着键/值对数量增加而线性增加。如果代码涉及大量查找操作，那么某些情况下可能选择 Object 更好一些。</p> <h4 id="_4-删除性能"><a href="#_4-删除性能" class="header-anchor">#</a> 4. 删除性能</h4> <p>使用 delete 删除 Object 属性的性能一直以来饱受诟病，目前在很多浏览器中仍然如此。为此，出现了一些伪删除对象属性的操作，包括把属性值设置为 undefined 或 null 。但很多时候，这都是一
种讨厌的或不适宜的折中。</p> <p>而对大多数浏览器引擎来说， Map 的 delete() 操作都比插入和查找更快。如果代码涉及大量删除操作，那么毫无疑问应该选择 Map 。</p> <h2 id="为什么-weakmap-和-weakset-的键只能使用对象"><a href="#为什么-weakmap-和-weakset-的键只能使用对象" class="header-anchor">#</a> 为什么 WeakMap 和 WeakSet 的键只能使用对象？</h2> <p>因为基本类型作为参数在函数中传递的是值的拷贝， WeakMap 和 WeakSet 没法判断 key 是否还在使用。</p> <ul><li>使用引用类型作为 key</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> m <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">WeakMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
m<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">)</span> <span class="token comment">// 由于 {} 没有在其他地方引用，所以在垃圾回收时，这个值也会被回收。</span>

<span class="token keyword">const</span> a <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
m<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">)</span> <span class="token comment">// 如果使用这种方式，则不会被回收。因为 {} 有 a 变量在引用它。</span>

a <span class="token operator">=</span> <span class="token keyword">null</span> <span class="token comment">// 将 a 置为空后，m 里的值 100 在垃圾回收时将会被回收。</span>
</code></pre></div><ul><li>如果允许基本类型作为 key</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> a <span class="token operator">=</span> <span class="token string">'abc'</span> <span class="token comment">// 由于基本数据类型在传递时，传递的是值，而不是引用。</span>
m<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">)</span>   <span class="token comment">// 所以执行 set 操作时，实际上是将新的 'abc' 和 100 关联起来，而不是原来 a 变量指向的那个。</span>
	              <span class="token comment">// 那这样就会有问题，m 里存储的永远是没有被引用的键，随时都会被回收。</span>
</code></pre></div><h2 id="javascript-事件循环"><a href="#javascript-事件循环" class="header-anchor">#</a> javascript 事件循环</h2> <p>javascript 是一门单线程的语言，会将执行的代码分为 <code>宏任务</code> 和 <code>微任务</code>。不同的代码会被推到不同的任务队列里，浏览器执行的过程中会先执行 <code>宏任务</code> 中的代码，执行完后会再执行 <code>微任务</code> 里的代码，执行完后再执行 <code>宏任务</code> 里的代码，依次类推，如下图：<br> <img src="/Front-end-interview/assets/img/js_event.20b24794.png" alt=""></p> <h3 id="宏任务"><a href="#宏任务" class="header-anchor">#</a> 宏任务</h3> <table><thead><tr><th>类型</th> <th>浏览器</th> <th>Node</th></tr></thead> <tbody><tr><td>script代码块</td> <td>✅</td> <td>✅</td></tr> <tr><td>setTimeout</td> <td>✅</td> <td>✅</td></tr> <tr><td>setInterval</td> <td>✅</td> <td>✅</td></tr> <tr><td>setImmediate</td> <td>❌</td> <td>✅</td></tr> <tr><td>requestAnimationFrame</td> <td>✅</td> <td>❌</td></tr></tbody></table> <h3 id="微任务"><a href="#微任务" class="header-anchor">#</a> 微任务</h3> <table><thead><tr><th>类型</th> <th>浏览器</th> <th>Node</th></tr></thead> <tbody><tr><td>process.nextTick</td> <td>❌</td> <td>✅</td></tr> <tr><td>MutationObserver</td> <td>✅</td> <td>❌</td></tr> <tr><td>Promise.then catch finally</td> <td>✅</td> <td>✅</td></tr> <tr><td>queueMicrotask</td> <td>✅</td> <td>✅</td></tr></tbody></table> <h3 id="总结"><a href="#总结" class="header-anchor">#</a> 总结</h3> <p>有一道测试题如下:</p> <div class="language-js extra-class"><pre class="language-js"><code>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'1'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'2'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  process<span class="token punctuation">.</span><span class="token function">nextTick</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'3'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">resolve</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'4'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'5'</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
process<span class="token punctuation">.</span><span class="token function">nextTick</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'6'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">resolve</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'7'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'8'</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>

<span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'9'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  process<span class="token punctuation">.</span><span class="token function">nextTick</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'10'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">resolve</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'11'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'12'</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><p>结合上面的知识点，结果为：1，7，6，8，2，4，3，5，9，11，10，12。<br>
这里需要注意的是在 setTimeout 回调执行完后会被认为一个 <code>宏任务</code> 执行结束，会去检测 <code>微任务</code> 队列，等 <code>微任务</code> 队列执行完后会再去检测 <code>宏任务</code> 队列（也就是说每一个 setTimeout 回调执行后就会看看是否有 <code>微任务</code> 有的话就执行）。在上面的例子里，第一个 setTimeout 回调执行完后，即使 <code>宏任务</code> 里还有一个 setTimeout 也不会立刻执行，而是回去查看 <code>微任务</code> 队列是否有可执行的。</p> <p>另外需要注意的是，如果处于微任务队列，又立即注册了立即执行的微任务，那么此微任务会立即执行：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>

<span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token parameter">resolve</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span>
  Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">_</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">_</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">_</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">)</span>
</code></pre></div><p>例如上述代码会输出：2，6，3，4，5，1</p> <h2 id="图解-dom-位置关系"><a href="#图解-dom-位置关系" class="header-anchor">#</a> 图解 DOM 位置关系</h2> <h3 id="位置关系图"><a href="#位置关系图" class="header-anchor">#</a> 位置关系图</h3> <p><img src="/Front-end-interview/assets/img/dom_position.824570a3.png" alt=""></p> <h3 id="尺寸关系图"><a href="#尺寸关系图" class="header-anchor">#</a> 尺寸关系图</h3> <p><img src="/Front-end-interview/assets/img/dom_size.c9f5bb1d.jpg" alt=""></p> <p>offsetHeight 可以用来计算元素的物理空间，此空间包括内容，padding 和 border（还包括滚动条的宽度，但大多时候滚动条的宽度是计算到 padding 和内容中的）。</p> <p>scrollHeight 用来计算可滚动容器的大小，包括不可见的部分。</p> <p>clientHeight 表示可视区域，包括内容和 padding ，如果有滚动条，还需要减去滚动条的宽度。</p> <p>常见用于判断是否滚动到页面底部的判断：scrollHeight - scrollTop === clientHeight。</p> <h2 id="常见的位运算符有哪些-其计算规则是什么"><a href="#常见的位运算符有哪些-其计算规则是什么" class="header-anchor">#</a> 常见的位运算符有哪些？其计算规则是什么？</h2> <table><thead><tr><th>运算符</th> <th><div style="width:80px;">描述</div></th> <th><div style="width:70px;">使用</div></th> <th>运算规则</th></tr></thead> <tbody><tr><td><code>&amp;</code></td> <td>按位与</td> <td><code>a &amp; b</code></td> <td>在 a、b 的位表示中，每一个对应的位，都为 1 则返回 1，否则返回 0</td></tr> <tr><td><code>|</code></td> <td>按位或</td> <td><code>a | b</code></td> <td>在 a、b 的位表示中，每一个对应的位，只要有一个为 1 则返回 1，否则返回 0</td></tr> <tr><td><code>^</code></td> <td>按位异或</td> <td><code>a ^ b</code></td> <td>在 a、b 的位表示中，每一个对应的位，两个不相同则返回 1，相同则返回 0</td></tr> <tr><td><code>~</code></td> <td>按位非</td> <td><code>~ a</code></td> <td>反转被操作数的位</td></tr> <tr><td><code>&lt;&lt;</code></td> <td>左移</td> <td><code>a &lt;&lt; b</code></td> <td>将 a 的二进制串向左移动 b 位，高位丢弃，低位补 0</td></tr> <tr><td><code>&gt;&gt;</code></td> <td>右移</td> <td><code>a &gt;&gt; b</code></td> <td>将 a 的二进制串向右移动 b 位，正数高位0，负数高位补1，低位丢弃</td></tr> <tr><td><code>&gt;&gt;&gt;</code></td> <td>无符号右移</td> <td><code>a &gt;&gt;&gt; b</code></td> <td>把 a 的二进制表示向右移动 b 位，丢弃被移出的所有位，并把左边空出的位都填充为 0</td></tr></tbody></table> <p>这里需要注意<code>右移</code>的时候高位根据符号位来填充，<code>无符号右移</code>的时候是用 0 填充。<br>
另外需要注意的是计算机存储负数的时候是用<code>补码</code>（反码 + 1）存储的，例如：<code>~6</code>，即</p> <div class="language-js extra-class"><pre class="language-js"><code>  <span class="token number">0000</span> <span class="token number">0110</span> <span class="token comment">// 原码</span>
  <span class="token number">1111</span> <span class="token number">1001</span> <span class="token comment">// 取反后的原码，发现是负数，立刻取反码</span>
  <span class="token number">1000</span> <span class="token number">0110</span> <span class="token comment">// 反码</span>
  <span class="token number">1000</span> <span class="token number">0111</span> <span class="token comment">// 补码，最终存储的结果为 -7</span>
</code></pre></div><p>最后说一下运用场景，由于位运算是在数字底层进行操作，优点在于运算速度快，但缺点很明显，不够直观。一个比较常见的运用场景是定义不同的状态，例如：ELEMENT_HTML: 1, ELEMENT_SVG: 1 &lt;&lt; 1 等等，可以参考：<a href="https://github.com/NameWjp/renderer/blob/master/src/flags.js" target="_blank" rel="noopener noreferrer">https://github.com/NameWjp/renderer/blob/master/src/flags.js<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <h2 id="escape-encodeuri-encodeuricomponent-的区别"><a href="#escape-encodeuri-encodeuricomponent-的区别" class="header-anchor">#</a> escape，encodeURI，encodeURIComponent 的区别</h2> <p>首先我们需要知道为什么要编码，编码的主要目的有以下几点：</p> <ul><li>URL 有规范，在参数值中出现 &amp; 字符会截断参数，所以当你的参数本来就有 &amp; 字符时如何不编码就会解析出错</li> <li>URL 使用中文不符合规范，容易出现乱码</li></ul> <h3 id="escape"><a href="#escape" class="header-anchor">#</a> escape</h3> <p>escape 是对字符串进行编码，作用是让它们在所有电脑上可读。编码之后的效果是 %XX 或者 %uXXXX 这种形式。其中 <code>ASCII字母 数字 @*/+</code> 这几个字符不会被编码，其余的都会。最关键的是，当你需要对 URL 编码时，请忘记这个方法，这个方法是针对字符串使用的，不适用于 URL。</p> <h3 id="encodeuri"><a href="#encodeuri" class="header-anchor">#</a> encodeURI</h3> <p>encodeURI 设计出来的目的就是为了编码整个 URL 的，不会对 <code>ASCII字母 数字 ~!@#$&amp;*()=:/,;?+'</code> 这些字符编码，编码出来的字符串可以直接访问。但是有时会有问题，例如：http//xxx?t==v，我们的本意是传递 <code>t=</code> 和 <code>v</code> 这一对查询条件，由于 encodeURI 不会对 <code>=</code> 进行编码，进而出现的问题。</p> <h3 id="encodeuricomponent"><a href="#encodeuricomponent" class="header-anchor">#</a> encodeURIComponent</h3> <p>encodeURIComponent 设计出来的目的是为了编码 URL 的查询参数的，它的编码范围更大，不会对 <code>ASCII字母 数字 ~!*()'</code> 这些字符编码。由于它可以编码 <code>? &amp;</code> 这类字符，所以它可以解决 encodeURI 出现的问题，例如：`http//xxx?${encodeURIComponent(t=)}=${encodeURIComponent(v)}`</p> <h2 id="对象的遍历顺序"><a href="#对象的遍历顺序" class="header-anchor">#</a> 对象的遍历顺序</h2> <p>对象的遍历并不是按照 key 加入的顺序来遍历的，而是按照以下的规则遍历：</p> <ol><li>首先遍历所有数值键（如果能转成数字的话），按照数值升序排列。</li> <li>其次遍历所有字符串键，按照加入时间升序排列。</li> <li>最后遍历所有 Symbol 键，按照加入时间升序排列。</li></ol> <h2 id="iterator-和-for-of-循环"><a href="#iterator-和-for-of-循环" class="header-anchor">#</a> Iterator 和 for...of 循环</h2> <p>遍历器（Iterator）是一种接口，为各种不同的数据结构提供统一的访问机制。任何数据结构只要部署 Iterator 接口，就可以完成遍历操作。Iterator 的作用有三个：一是为各种数据结构，提供一个统一的、简便的访问接口；二是使得数据结构的成员能够按某种次序排列；三是 ES6 创造了一种新的遍历命令 for...of 循环，Iterator 接口主要供 for...of 消费。</p> <p>原生具备 Iterator 接口的数据结构如下：Array、Map、Set、String、TypedArray、函数的 arguments 对象、NodeList 对象。</p> <p>参考：<a href="https://es6.ruanyifeng.com/#docs/iterator#Iterator%EF%BC%88%E9%81%8D%E5%8E%86%E5%99%A8%EF%BC%89%E7%9A%84%E6%A6%82%E5%BF%B5" target="_blank" rel="noopener noreferrer">Iterator 和 for...of 循环<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/Front-end-interview/" class="prev router-link-active">
        简介
      </a></span> <span class="next"><a href="/Front-end-interview/implement.html">
        手写和实现
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/Front-end-interview/assets/js/app.fdae9a04.js" defer></script><script src="/Front-end-interview/assets/js/2.2ef4b7ab.js" defer></script><script src="/Front-end-interview/assets/js/4.99bb1ea4.js" defer></script>
  </body>
</html>
