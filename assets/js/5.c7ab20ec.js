(window.webpackJsonp=window.webpackJsonp||[]).push([[5],{366:function(t,a,v){t.exports=v.p+"assets/img/browser_cache.b5f8d670.jpg"},367:function(t,a,v){t.exports=v.p+"assets/img/http_1.9efb4cf1.png"},368:function(t,a,v){t.exports=v.p+"assets/img/http_2.0d8bdafc.png"},369:function(t,a,v){t.exports=v.p+"assets/img/http_3.1d9692a9.jpeg"},370:function(t,a,v){t.exports=v.p+"assets/img/dns_parse.5ea757f0.jpg"},411:function(t,a,v){"use strict";v.r(a);var _=v(45),e=Object(_.a)({},(function(){var t=this,a=t.$createElement,_=t._self._c||a;return _("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[_("h2",{attrs:{id:"get-post-请求有什么区别"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#get-post-请求有什么区别"}},[t._v("#")]),t._v(" GET/POST 请求有什么区别")]),t._v(" "),_("p",[t._v("GET 和 POST，两者是 HTTP 协议中发送请求的方法，本质上都是 TCP 链接，并无差别。但是由于 HTTP 的规定和浏览器/服务器的限制，导致他们在应用过程中会体现出一些区别。")]),t._v(" "),_("h3",{attrs:{id:"get"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#get"}},[t._v("#")]),t._v(" GET")]),t._v(" "),_("p",[t._v("GET 表示读取一个资源。比如 Get 到一个 html 文件，反复读取不应该对访问的数据有副作用。因为 GET 是读取，所以可以对 GET 请求的数据做缓存。")]),t._v(" "),_("h3",{attrs:{id:"post"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#post"}},[t._v("#")]),t._v(" POST")]),t._v(" "),_("p",[t._v("POST 方法用于将实体提交到指定的资源，通常导致在服务器上的状态变化或副作用。")]),t._v(" "),_("h3",{attrs:{id:"区别"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#区别"}},[t._v("#")]),t._v(" 区别")]),t._v(" "),_("ul",[_("li",[t._v("GET 参数通过URL传递，POST 放在 Request body中")]),t._v(" "),_("li",[t._v("GET 请求在 URL 中传送的参数是有长度限制（浏览器的限制），而POST没有。")]),t._v(" "),_("li",[t._v("GET 请求会被浏览器主动 cache，而 POST 不会。")]),t._v(" "),_("li",[t._v("POST 比 GET 安全，因为数据在地址栏上不可见。")])]),t._v(" "),_("p",[t._v("参考："),_("a",{attrs:{href:"https://github.com/febobo/web-interview/issues/145",target:"_blank",rel:"noopener noreferrer"}},[t._v("说一下 GET 和 POST 的区别"),_("OutboundLink")],1)]),t._v(" "),_("h2",{attrs:{id:"一个-tcp-连接能发几个-http-请求"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#一个-tcp-连接能发几个-http-请求"}},[t._v("#")]),t._v(" 一个 TCP 连接能发几个 HTTP 请求?")]),t._v(" "),_("p",[t._v("HTTP/1.0 版本协议一个 TCP 只能发送一个 HTTP 请求，但是服务器实现了 Connection: Keep-Alive，因此一个 TCP 可以发送多个 HTTP 请求但请求不能并发，大多数浏览器只允许同时对同一域名建立 6 个 TCP 连接，所以大多数浏览器同一时间只能发送 6（只针对同一域，不同域的并发是分别计算的）。"),_("br"),t._v("\nHTTP/1.1 版本将 Connection: Keep-Alive 纳入标准。"),_("br"),t._v("\nHTTP/2.0 版本协议，支持多路复用，一个 TCP 连接是可以并发多个 HTTP 请求的，理论上 HTTP/2.0 协议支持在同一个 TCP 连接上发送无限个 HTTP 请求，且这些请求的生命期可以重叠。")]),t._v(" "),_("h2",{attrs:{id:"http-缓存"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#http-缓存"}},[t._v("#")]),t._v(" HTTP 缓存")]),t._v(" "),_("p",[t._v("HTTP 缓存主要分为以下两种：")]),t._v(" "),_("ol",[_("li",[t._v("强缓存")]),t._v(" "),_("li",[t._v("协商缓存")])]),t._v(" "),_("p",[t._v("浏览器从请求接口到呈现页面会经过以下阶段："),_("br"),t._v(" "),_("img",{attrs:{src:v(366),alt:""}}),_("br"),t._v("\n两者的主要区别是使用本地缓存的时候，是否需要向服务器验证本地缓存是否依旧有效。顾名思义，协商缓存，就是需要和服务器进行协商，最终确定是否使用本地缓存。")]),t._v(" "),_("h3",{attrs:{id:"强缓存"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#强缓存"}},[t._v("#")]),t._v(" 强缓存")]),t._v(" "),_("p",[t._v("当浏览器向服务器发起请求时，服务器会将缓存规则放入 HTTP "),_("strong",[t._v("响应报文")]),t._v("的 HTTP 头中和请求结果一起返回给浏览器，控制强制缓存的字段分别是 Expires 和 Cache-Control，其中 Cache-Control 优先级比 Expires 高。当浏览器从缓存里拿数据的时候 http 里会显示 Memory Cache 或 Disk Cache。")]),t._v(" "),_("h4",{attrs:{id:"expires"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#expires"}},[t._v("#")]),t._v(" Expires")]),t._v(" "),_("p",[t._v("Expires 是 http1.0 提出的一个表示资源过期时间的 header，它描述的是一个绝对时间，由服务器返回。由于设置的是绝对时间，当客户端在不同的时区时，则过期时间就会发生误差。")]),t._v(" "),_("div",{staticClass:"language- extra-class"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[t._v("Expires: Wed, 11 May 2018 07:20:00 GMT\n")])])]),_("h4",{attrs:{id:"cache-control"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#cache-control"}},[t._v("#")]),t._v(" Cache-Control")]),t._v(" "),_("p",[t._v("Cache-Control 出现于 HTTP/1.1，优先级高于 Expires，表示的是相对时间。设置 max-age 字段为 300 则表示缓存该结果 300 秒。需要注意的是请求头也可以设置 Cache-Control，表示我需要什么样的缓存，但是"),_("strong",[t._v("响应报文")]),t._v("是否有 Cache-Control 是由后端配置的。另外 Chrome 会在强制刷新浏览器或者 Network 模块勾选 Disable cache 后会在请求头里面携带 "),_("code",[t._v("Cache-Control: no-cache")]),t._v("。")]),t._v(" "),_("div",{staticClass:"language- extra-class"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[t._v("Cache-Control: max-age=300\n")])])]),_("p",[t._v("tips: Cache-Control 的其他用法")]),t._v(" "),_("ul",[_("li",[t._v("no-cache：表示在使用缓存之前，强制要求缓存把请求提交给原始服务器进行验证(协商缓存验证)。")]),t._v(" "),_("li",[t._v("no-store：不使用任何缓存。")]),t._v(" "),_("li",[t._v("public：表明响应可以被任何对象（包括：发送请求的客户端，代理服务器，等等）缓存，即使是通常不可缓存的内容。（例如：1.该响应没有 max-age 指令或 Expires 消息头；2.该响应对应的请求方法是 POST 。）")]),t._v(" "),_("li",[t._v("private：表明响应只能被单个用户缓存，不能作为共享缓存（即代理服务器不能缓存它）。私有缓存可以缓存响应内容，比如：对应用户的本地浏览器。")])]),t._v(" "),_("h4",{attrs:{id:"强缓存失效的办法"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#强缓存失效的办法"}},[t._v("#")]),t._v(" 强缓存失效的办法")]),t._v(" "),_("ol",[_("li",[t._v("手动清除浏览器缓存")]),t._v(" "),_("li",[t._v("改变文件名称")]),t._v(" "),_("li",[t._v("在请求的文件名称后面带上版本号")])]),t._v(" "),_("h3",{attrs:{id:"协商缓存"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#协商缓存"}},[t._v("#")]),t._v(" 协商缓存")]),t._v(" "),_("p",[t._v("当浏览器对某个资源的请求没有命中强缓存（过期或者之前响应头设置为 "),_("code",[t._v("no-cache")]),t._v("），就会发一个请求到服务器，验证协商缓存是否命中，如果协商缓存命中，请求响应返回的 http 状态为 304 并且会显示一个 Not Modified 的字符串")]),t._v(" "),_("p",[t._v("协商缓存是利用的是【Last-Modified，If-Modified-Since】和【ETag、If-None-Match】这两对Header来管理的。")]),t._v(" "),_("h4",{attrs:{id:"last-modified、if-modified-since"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#last-modified、if-modified-since"}},[t._v("#")]),t._v(" Last-Modified、If-Modified-Since")]),t._v(" "),_("p",[t._v("Last-Modified 表示本地文件最后修改日期，浏览器会在 request header 加上 If-Modified-Since（上次请求返回的 Last-Modified 的值），询问服务器在该日期后资源是否有更新，有更新的话就会将新的资源发送回来")]),t._v(" "),_("p",[t._v("但是如果在本地打开缓存文件，就会造成 Last-Modified 被修改，所以在 HTTP/1.1 出现了 ETag")]),t._v(" "),_("h4",{attrs:{id:"etag、if-none-match"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#etag、if-none-match"}},[t._v("#")]),t._v(" ETag、If-None-Match")]),t._v(" "),_("p",[t._v("Etag 就像一个指纹，资源变化都会导致 ETag 变化，跟最后修改时间没有关系，ETag 可以保证每一个资源是唯一的")]),t._v(" "),_("p",[t._v("If-None-Match 的 header 会将上次返回的 Etag 发送给服务器，询问该资源的 Etag 是否有更新，有变动就会发送新的资源回来。")]),t._v(" "),_("h3",{attrs:{id:"总结"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[t._v("#")]),t._v(" 总结")]),t._v(" "),_("p",[t._v("HTTP/1.1 的缓存机制对比 HTTP/1.0 的缓存机制有以下优点：")]),t._v(" "),_("ol",[_("li",[t._v("使用相对时间设置强缓存，解决了不同时区不同客户端缓存时间不同的问题。")]),t._v(" "),_("li",[t._v("使用 ETag 代替 Last-Modified，解决了打开文件不修改，缓存会失效的问题。")])]),t._v(" "),_("h2",{attrs:{id:"keep-alive-和多路复用的区别"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#keep-alive-和多路复用的区别"}},[t._v("#")]),t._v(" keep-alive 和多路复用的区别")]),t._v(" "),_("h3",{attrs:{id:"区别-2"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#区别-2"}},[t._v("#")]),t._v(" 区别")]),t._v(" "),_("p",[t._v("keep-alive 是指 TCP 处理完一个 HTTP 连接后不关闭，可以继续处理下一个 HTTP 连接（阻塞的）。多路复用是 HTTP2 的特性，指多个 HTTP 连接可以同时在一个 TCP 连接上处理（并行的）。")]),t._v(" "),_("h3",{attrs:{id:"原因"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#原因"}},[t._v("#")]),t._v(" 原因")]),t._v(" "),_("p",[t._v("在 HTTP1.1 的协议中，我们传输的 request 和 response 都是基本于文本的，这样就会引发一个问题：所有的数据必须按顺序传输，比如需要传输：hello world，只能从 h 到 d 一个一个的传输，不能并行传输，因为接收端并不知道这些字符的顺序，所以并行传输在 HTTP1.1 是不能实现的。我们假设 Apache 设置了最大并发数为 300，因为浏览器限制，浏览器发起的最大请求数为6，也就是服务器能承载的最高并发为 50。"),_("br"),t._v(" "),_("img",{attrs:{src:v(367),alt:""}}),_("br"),t._v("\nHTTP/2 引入二进制数据帧和流的概念，其中帧对数据进行顺序标识，如下图所示，这样浏览器收到数据之后，就可以按照序列对数据进行合并，而不会出现合并后数据错乱的情况。同样是因为有了序列，服务器就可以并行的传输数据，这就是流所做的事情。HTTP/2 对同一域名下所有请求都是基于流，也就是说同一域名不管访问多少文件，也只建立一路连接。同样 Apache 的最大连接数为 300，因为有了这个新特性，最大的并发就可以提升到 300，比原来提升了 6 倍！"),_("br"),t._v(" "),_("img",{attrs:{src:v(368),alt:""}})]),t._v(" "),_("h2",{attrs:{id:"http-状态码"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#http-状态码"}},[t._v("#")]),t._v(" HTTP 状态码")]),t._v(" "),_("h3",{attrs:{id:"基本分类"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#基本分类"}},[t._v("#")]),t._v(" 基本分类")]),t._v(" "),_("table",[_("thead",[_("tr",[_("th",[t._v("状态码")]),t._v(" "),_("th",[t._v("类别")]),t._v(" "),_("th",[t._v("描述")])])]),t._v(" "),_("tbody",[_("tr",[_("td",[t._v("1xx")]),t._v(" "),_("td",[t._v("Informational（信息状态码）")]),t._v(" "),_("td",[t._v("接受请求正在处理")])]),t._v(" "),_("tr",[_("td",[t._v("2xx")]),t._v(" "),_("td",[t._v("Success（成功状态码）")]),t._v(" "),_("td",[t._v("请求正常处理完毕")])]),t._v(" "),_("tr",[_("td",[t._v("3xx")]),t._v(" "),_("td",[t._v("Redirection（重定向状态码）")]),t._v(" "),_("td",[t._v("需要附加操作已完成请求")])]),t._v(" "),_("tr",[_("td",[t._v("4xx")]),t._v(" "),_("td",[t._v("Client Error（客户端错误状态码）")]),t._v(" "),_("td",[t._v("服务器无法处理请求")])]),t._v(" "),_("tr",[_("td",[t._v("5xx")]),t._v(" "),_("td",[t._v("Server Error（服务器错误状态码）")]),t._v(" "),_("td",[t._v("服务器处理请求出错")])])])]),t._v(" "),_("h3",{attrs:{id:"常见状态码"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#常见状态码"}},[t._v("#")]),t._v(" 常见状态码")]),t._v(" "),_("table",[_("thead",[_("tr",[_("th",[t._v("状态码")]),t._v(" "),_("th",[t._v("类别")]),t._v(" "),_("th",[t._v("描述")])])]),t._v(" "),_("tbody",[_("tr",[_("td",[t._v("200")]),t._v(" "),_("td",[t._v("Success（成功状态码）")]),t._v(" "),_("td",[t._v("请求成功")])]),t._v(" "),_("tr",[_("td",[t._v("301")]),t._v(" "),_("td",[t._v("Redirection（重定向状态码）")]),t._v(" "),_("td",[t._v("永久重定向")])]),t._v(" "),_("tr",[_("td",[t._v("302")]),t._v(" "),_("td",[t._v("Redirection（重定向状态码）")]),t._v(" "),_("td",[t._v("临时重定向")])]),t._v(" "),_("tr",[_("td",[t._v("304")]),t._v(" "),_("td",[t._v("Not Modified（未改变）")]),t._v(" "),_("td",[t._v("资源未修改，可以使用缓存")])]),t._v(" "),_("tr",[_("td",[t._v("403")]),t._v(" "),_("td",[t._v("Client Error（客户端错误状态码）")]),t._v(" "),_("td",[t._v("服务器拒绝请求")])]),t._v(" "),_("tr",[_("td",[t._v("404")]),t._v(" "),_("td",[t._v("Client Error（客户端错误状态码）")]),t._v(" "),_("td",[t._v("资源不存在")])]),t._v(" "),_("tr",[_("td",[t._v("500")]),t._v(" "),_("td",[t._v("Server Error（服务器错误状态码）")]),t._v(" "),_("td",[t._v("服务器错误")])])])]),t._v(" "),_("p",[t._v("参考："),_("a",{attrs:{href:"https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status",target:"_blank",rel:"noopener noreferrer"}},[t._v("HTTP状态码"),_("OutboundLink")],1)]),t._v(" "),_("h2",{attrs:{id:"https加密过程详解"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#https加密过程详解"}},[t._v("#")]),t._v(" HTTPS加密过程详解")]),t._v(" "),_("h3",{attrs:{id:"https加密过程"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#https加密过程"}},[t._v("#")]),t._v(" HTTPS加密过程")]),t._v(" "),_("ol",[_("li",[t._v("客户端请求服务器获取证书公钥")]),t._v(" "),_("li",[t._v("客户端(SSL/TLS)验证证书（无效会弹出警告）")]),t._v(" "),_("li",[t._v("生成随机值")]),t._v(" "),_("li",[t._v("用公钥加密随机值生成密钥")]),t._v(" "),_("li",[t._v("客户端将密钥发送给服务器")]),t._v(" "),_("li",[t._v("服务端用私钥解密钥得到随机值")]),t._v(" "),_("li",[t._v("将信息和随机值混合在一起进行对称加密")]),t._v(" "),_("li",[t._v("将加密的内容发送给客户端")]),t._v(" "),_("li",[t._v("客户端用秘钥解密信息")])]),t._v(" "),_("h3",{attrs:{id:"客户端验证证书"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#客户端验证证书"}},[t._v("#")]),t._v(" 客户端验证证书")]),t._v(" "),_("ol",[_("li",[t._v("客户端得到服务端返回的证书，通过读取得到服务端证书的发布机构（CA）。")]),t._v(" "),_("li",[t._v("客户端去操作系统查找这个发布机构的的证书，如果不是根证书就继续递归下去，直到拿到根证书。")]),t._v(" "),_("li",[t._v("用根证书（根证书内置于操作系统中）的公钥去解密验证上一层证书的合法性，再拿上一层证书的公钥去验证更上层证书的合法性，递归回溯。")]),t._v(" "),_("li",[t._v("最后验证服务器端的证书是可信任的。")])]),t._v(" "),_("p",[_("img",{attrs:{src:v(369),alt:""}})]),t._v(" "),_("h2",{attrs:{id:"域名解析流程"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#域名解析流程"}},[t._v("#")]),t._v(" 域名解析流程")]),t._v(" "),_("p",[_("img",{attrs:{src:v(370),alt:""}})])])}),[],!1,null,null,null);a.default=e.exports}}]);